<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[明白原理，轻松应对Android内存泄漏]]></title>
      <url>http://yoursite.com/2017/02/11/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<p>相信“内存泄漏”问题，是一个挺让开发者头疼的事情，笔者在回顾以为代码时，惊讶发现：初学Android时，许多不修边幅的代码习惯，导致了许多内存泄漏问题，因此特来分析一下，把自己挖过的坑补一下，也希望奔跑在Android开发道路上的你能够优雅避免~<a id="more"></a></p>
<p><strong>内存泄漏本质原因：</strong>忘记释放分配的内存；应用不需要某对象时候，该对象仍然保持被引用状态（当对象拥有强引用，GC无法回收），而具体的GC机制请见：<a href="http://www.jianshu.com/p/eff9786180ec" target="_blank" rel="external">Java进阶 - JVM 内存管理机制探秘</a>中的“GC机制与内存分配策略”部分。</p>
<h3 id="概述：Context-最容易引发内存泄漏"><a href="#概述：Context-最容易引发内存泄漏" class="headerlink" title="概述：Context - 最容易引发内存泄漏"></a>概述：Context - 最容易引发内存泄漏</h3><p>Activity、Service、Applictaion；（BroadcastReceiver、ContentProvider虽然不在Context继承树，但其内部会持有Context）<br><strong>原理：</strong>很可能Activity作为Context传递给某些类，Activity生命周期结束之后，某些类仍然存活并保持着该Activity的引用，Activity是重量级对象，却保持引用无法被回收。</p>
<p>不熟悉Context？请见：<a href="http://blog.csdn.net/lmj623565791/article/details/40481055/" target="_blank" rel="external"> Android Context 上下文 你必须知道的一切</a></p>
<p>主要的两种情况：</p>
<ul>
<li>全局进程持有Activity强引用（某个单例类一直持有引用）</li>
<li>与Activity生命周期无关的的线程，在Activity生命周期结束时，没有清空Activity引用</li>
</ul>
<h3 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a>static 变量</h3><p><strong>例如：</strong></p>
<ul>
<li>static Activity activity = this；（听说C++开发中常喜欢通过这样的方式管理类，而放到Java上，似乎并不合适。）<br><strong>原理：</strong>static变量贯穿应用生命周期，泄漏的Activity会一直存在。</li>
<li>static view，Activity销毁时候没有设为null；<br><strong>原理：</strong>将View设置为static，不建议这么做，LayoutInflater需要使用context来加载layout，那么View最终会持有Activity引用，生命周期结束没有设置null，Activity也会一直存在。</li>
</ul>
<p><strong>解决：</strong></p>
<ol>
<li>尽量避免使用static变量；</li>
<li>如果逻辑上允许，则使用弱引用，可能会有NullPointerException风险（无论内存是否足够，只能生存到下一次GC之前。使用WeakReference 类实现）；</li>
<li>继续使用static变量，记得在Activity被销毁的时候，释放static变量引用。</li>
</ol>
<h3 id="非静态内部类、匿名内部类持有外部类的引用"><a href="#非静态内部类、匿名内部类持有外部类的引用" class="headerlink" title="非静态内部类、匿名内部类持有外部类的引用"></a>非静态内部类、匿名内部类持有外部类的引用</h3><p><strong>原理：</strong>简单来说，编译的时候，编译器会自动为内部类构造方法中加上外部类的引用。详情请见：<a href="http://blog.csdn.net/zhangjg_blog/article/details/20000769" target="_blank" rel="external">深入理解Java中为什么内部类可以访问外部类的成员</a><br>如果外部还对这样的内部类持有一个<strong>static引用</strong>，那么很有可能导致内存泄漏。</p>
<p><strong>例如：</strong></p>
<ul>
<li><strong>匿名的AsyncTask</strong>被execute，尽管Activity被销毁，也需要等异步任务全部完成才可销毁，<strong>匿名的Thread</strong>，也是类似的道理；</li>
<li><strong>Handler：</strong>内部类、匿名类创建Handler，会使得Handler持有外部Activity引用，而Handler与<a href="http://www.jianshu.com/p/9c27d1f713a2" target="_blank" rel="external">Android消息机制</a>密切相关，当Handler发出Message，Message进入MessageQueue，等待Looper取出来交给Handler进行handleMessage，这漫长的消息链，会让Activity一直引用，生命周期结束了，也不可被销毁；</li>
</ul>
<p><strong>解决：</strong></p>
<ol>
<li>使用静态内部类，静态内部类内部使用弱引用来引外外部类，因为静态内部类并不会持有外部类引用，这样就有效打破了引用链（Handler内存泄漏问题推荐，其他类型也可使用该方式避免）；</li>
<li>当Activity被销毁或者不需要AsyncTask、Thread时，停止异步任务、线程任务；</li>
</ol>
<h3 id="使用Context获取系统服务"><a href="#使用Context获取系统服务" class="headerlink" title="使用Context获取系统服务"></a>使用Context获取系统服务</h3><p><strong>原理：</strong>当使用Context.getSystemService(int name)方法，获取系统服务时候，某些服务处于系统进程中一直存在，如果传入Activity引用，也会导致内存泄漏问题。<br><strong>解决：</strong>记得Activity被销毁时候，断开与系统服务的联系（如：registerListener、unregisterListener）</p>
<h3 id="属性动画导致的内存泄漏"><a href="#属性动画导致的内存泄漏" class="headerlink" title="属性动画导致的内存泄漏"></a>属性动画导致的内存泄漏</h3><p><strong>原理：</strong>Android 3.0 后，属性动画出现，其中有一类无限循环的动画，如果Activity没有在onDestroy方法中停止动画，尽管用户看不见，动画会一直播放下去，执行属性动画的View被动画持有引用，而Activity又被View持有引用，导致Activity也无法释放。<br><strong>解决：</strong>在Activity销毁时，调用animator.cancel()来停止动画即可</p>
<h3 id="学习资源推荐"><a href="#学习资源推荐" class="headerlink" title="学习资源推荐"></a>学习资源推荐</h3><ul>
<li><a href="http://www.jianshu.com/p/ac00e370f83d" target="_blank" rel="external">[译]Android内存泄漏的八种可能（上）</a></li>
<li><a href="http://www.jianshu.com/p/c5ac51d804fa" target="_blank" rel="external">[译]Android防止内存泄漏的八种方法（下）</a></li>
<li><a href="https://my.oschina.net/rengwuxian/blog/181449" target="_blank" rel="external">Handler造成内存泄漏的分析与解决</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[拆轮子系列 - 如何由浅入深探索 Retrofit 源码？]]></title>
      <url>http://yoursite.com/2017/01/15/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%B3%BB%E5%88%97%20-%20Retrofit/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信点开文章的你，多少也知道或者使用过Retrofit框架吧。如果你有一颗想对源码一探究竟的心，却不知如何入手。笔者一直也有这样的困惑，也正在努力总结出一套有效的分析源码方法，希望本文的拆轮子思路能给你带来一些帮助。<a id="more"></a></p>
<p>本文记录了笔者基于 <a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit 2.1.0</a> 源码的学习分析过程，文中拆解思路很大程度受到<a href="http://www.jianshu.com/u/6e4c6553a7f9" target="_blank" rel="external">Stay4it</a>所制作的教程启发（良心教程，文末有链接，配合视频食用本文效果更佳），故跟随该教程结合自身见解进行一番记录，如有错漏，恳请指正。</p>
<p><strong>探索方式：</strong></p>
<ol>
<li>学会用该框架，动手写Demo，理解框架应用场景，基本特点（前提）。</li>
<li>利用网络资源，搜寻多篇前人写过的拆轮子资源，下载源码，跟随资源进行源码跟踪，如果不动手，我认为是很难将框架理解的。</li>
<li>阅读源码时，学会总结：从Retrofit一般使用方式入手，通过断点调试，观察源码执行顺序，忽略非重要代码，摸清源码主线实现思路后，再深入探索其中的细节实现。</li>
<li>回顾与整理，最后再过一遍思路，若走通了，那么框架的大概就理解了，同时整理笔记，便于日后忘了回来查看。</li>
</ol>
<h2 id="网络请求框架的基本流程"><a href="#网络请求框架的基本流程" class="headerlink" title="网络请求框架的基本流程"></a>网络请求框架的基本流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/1513860-e5d7b7ad70dc5a37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ol>
<li>构建Request，入队</li>
<li>进入Executor执行，Looper不断循环，拿到Request执行</li>
<li>执行结果的解析与返回</li>
</ol>
<h2 id="Retrofit-概述（WHAT）"><a href="#Retrofit-概述（WHAT）" class="headerlink" title="Retrofit 概述（WHAT）"></a>Retrofit 概述（WHAT）</h2><p>一个在Android/Java平台上运行的type-safe HTTP Client，其中type-safe是通过声明泛型来保证的，支持RxJava，解耦程度高，基于 Retrofit 2.0.1,当前最新版2.1.0，即将出版2.2.0。（2017.1.）</p>
<h3 id="构建Request"><a href="#构建Request" class="headerlink" title="构建Request"></a>构建Request</h3><p>Retrofit通过注解来构建Request,所有的参数都可以简单配置完毕，上层不需要关心底层使用何种方式实现构建Request过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</div><div class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</div><div class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="实现Executor"><a href="#实现Executor" class="headerlink" title="实现Executor"></a>实现Executor</h3><p>实现上述声明的接口，得到可以做具体请求操作的实现类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">GitHubService service = retrofit.create(GitHubService.class);</div></pre></td></tr></table></figure></p>
<p><strong>相关概念</strong><br><strong>CallAdapter：</strong>Adapter a Call into  the type of T.（将一个Call适配为另外一个Call的适配器接口）</p>
<ul>
<li>Type responseType()：将返回的请求转化为参数Type类型</li>
<li>T adapt(Call<r> call)：将一个Call转换成另外一个Call</r></li>
</ul>
<h3 id="HTTP-Call"><a href="#HTTP-Call" class="headerlink" title="HTTP Call"></a>HTTP Call</h3><p>调用上述实现类的方法即可得到Call，而Retrofit内部使用OkHttp实现HTTP Call，最后通过Converter转换成用户想要的对象体。<br>Call：An invocation of a Retrofit method that sends a request to a webserver and returns a response.（请求发送与响应返回方法的调用）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="主线用例"><a href="#主线用例" class="headerlink" title="主线用例"></a>主线用例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 源码剖析 - 步骤1~4</span></div><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">            .baseUrl(<span class="string">"http://gank.io/"</span>)</div><div class="line">            .addConverterFactory(GsonConverterFactory.create())</div><div class="line">            .build();</div><div class="line">    <span class="comment">// 源码剖析 - 步骤5~6</span></div><div class="line">    Api api = retrofit.create(Api.class);</div><div class="line">    <span class="comment">// 源码剖析 - 步骤7</span></div><div class="line">    Call&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt; call = api.defaultBenefits(<span class="number">20</span>, page++);</div><div class="line"></div><div class="line">    call.enqueue(<span class="keyword">new</span> Callback&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt;() &#123;</div><div class="line">                 <span class="meta">@Override</span></div><div class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt; call, Response&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt; response)</span> </span>&#123;</div><div class="line">                     <span class="keyword">if</span> (action == PullRecycler.ACTION_PULL_TO_REFRESH) &#123;</div><div class="line">                         mDataList.clear();</div><div class="line">                     &#125;</div><div class="line">                     <span class="keyword">if</span> (response.body().results == <span class="keyword">null</span> || response.body().results.size() == <span class="number">0</span>) &#123;</div><div class="line">                         recycler.enableLoadMore(<span class="keyword">false</span>);</div><div class="line">                     &#125; <span class="keyword">else</span> &#123;</div><div class="line">                         recycler.enableLoadMore(<span class="keyword">true</span>);</div><div class="line">                         mDataList.addAll(response.body().results);</div><div class="line">                         adapter.notifyDataSetChanged();</div><div class="line">                     &#125;</div><div class="line">                     recycler.onRefreshCompleted();</div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="meta">@Override</span></div><div class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">                     recycler.onRefreshCompleted();</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="Retrofit主线源码剖析（HOW-Part-1）"><a href="#Retrofit主线源码剖析（HOW-Part-1）" class="headerlink" title="Retrofit主线源码剖析（HOW - Part 1）"></a>Retrofit主线源码剖析（HOW - Part 1）</h2><ol>
<li><p><strong>Retrofit对象的创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">        .baseUrl(<span class="string">"http://gank.io/"</span>)</div><div class="line">        .addConverterFactory(GsonConverterFactory.create())</div><div class="line">        .build();</div></pre></td></tr></table></figure>
</li>
<li><p><strong>build()方法内部</strong><br><strong>构建Retrofit对象主要思路：</strong>1、创建callbackExecutor（内部获取主线程MainLooper来构建Hanlder，其execute方法本质是Handler.post(runnable)，待用于线程切换）；2、构建adapterFactories集合，将defaultAdapterFactory加入其中（ExecutorCallAdapterFactory类，<strong>线程切换关键实现</strong>，内部持有OkHttp代理delegate，在delegate.enqueue中的onRespond方法内使用刚刚创建的callbackExecutor.execute方法，从而实现线程切换）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  <span class="comment">// 创建OkHttp，目前Retrofit只支持OkHttp</span></div><div class="line">  okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</div><div class="line">  <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</div><div class="line">    callFactory = <span class="keyword">new</span> OkHttpClient();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 创建Executor，见步骤3</span></div><div class="line">  Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</div><div class="line">  <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">    callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></div><div class="line">  <span class="comment">// 对adapters进行保护性拷贝，并且加入默认的call adapter（使用上面创建的Executor来构建，可以认为是把主线程中的Handler传入）</span></div><div class="line">  <span class="comment">// 构建adapterFactories集合，将defaultAdapterFactory加入其中，见步骤4</span></div><div class="line">  List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</div><div class="line">  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line"></div><div class="line">  <span class="comment">// Make a defensive copy of the converters.</span></div><div class="line">  <span class="comment">// 对converters进行保护性拷贝</span></div><div class="line">  <span class="comment">// 一般传入的为GsonConverterFactory对象，其作用主要是将json转换成java对象</span></div><div class="line">  List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</div><div class="line"></div><div class="line">  <span class="comment">//最终完成Retrofit对象构建</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</div><div class="line">      callbackExecutor, validateEagerly);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Executor的获取 - platform.defaultCallbackExecutor();</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 返回MainThreadExecutor</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Platform.Android.MainThreadExecutor();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">        <span class="comment">// 从主线程得到MainLooper，构建Handler</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">            <span class="comment">// execute方法本质：通过handler，在主线程上执行该runnable</span></div><div class="line">            handler.post(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>详解 platform.defaultCallAdapterFactory(callbackExecutor) - 线程切换的关键</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// platform.defaultCallAdapterFactory(callbackExecutor)</span></div><div class="line">CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (callbackExecutor != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> DefaultCallAdapterFactory.INSTANCE;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ExecutorCallAdapterFactory构造方法</span></div><div class="line"><span class="comment">// ExecutorCallAdapterFactory通过传参，得到callbackExecutor</span></div><div class="line">ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</div><div class="line">  <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// get方法，创建并返回Android平台默认CallAdapter</span></div><div class="line"> <span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> responseType;</div><div class="line">      &#125;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="comment">//----------------------------分割线-----------------------------------</span></div><div class="line"> <span class="comment">// ExecutorCallAdapterFactory内部类ExecutorCallbackCall中enqueue方法，子线程转换为主线程的关键</span></div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (callback == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback == null"</span>);</div><div class="line">  <span class="comment">// 子线程中执行，此处的delegate本质是OkHttpCall（主要用于对接OkHttp框架）</span></div><div class="line">  delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(<span class="keyword">final</span> Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</div><div class="line">      <span class="comment">// 响应请求，调用callbackExecutor的execute</span></div><div class="line">      <span class="comment">// 从步骤3中可知，该方法本质是调用主线程的Handler执行runnable</span></div><div class="line">      <span class="comment">// 包裹用户传入的callback，从而实现线程切换 </span></div><div class="line">      callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">      <span class="meta">@Override</span> </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (delegate.isCanceled()) &#123;</div><div class="line">            <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException oncancellation.</span></div><div class="line">            callback.onFailure(call, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            callback.onResponse(call, response);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(<span class="keyword">final</span> Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</div><div class="line">      <span class="comment">// 包裹用户传入的callback，从而实现线程切换 </span></div><div class="line">      callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">          callback.onFailure(call, t);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>详解：retrofit.create(Api.class)</strong><br><strong>创建接口实现类：</strong>创建并返回一个会拦截接口方法的动态代理对象实例 - 接口方法被调用时，会被其拦截，内部将接口方法适配成HTTP Call，再构造对应的OkHttpCall，最后通过CallAdapter.adapt()转换成Retrofit适用的call delegates（即ExecutorCallbackCall）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Api api = retrofit.create(Api.class);</div><div class="line"><span class="comment">// create方法内部实现，返回一个动态代理实例</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 该动态代理会对接口方法进行拦截</span></div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="comment">// 创建一个InvocationHandler，接口方法被调用时会被拦截调用</span></div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line">    <span class="comment">// 当Api接口方法被调用时，会调用invoke方法拦截</span></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line">              <span class="keyword">throws</span> Throwable &#123;</div><div class="line">            ...</div><div class="line">            <span class="comment">// 通过解析api方法注解、传参，将接口中方法适配成HTTP Call，详解见步骤6</span></div><div class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">            <span class="comment">// 拦截下来之后，内部构建一个okHttpCall</span></div><div class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="comment">// 最后通过callAdapter将okHttpCall转换成为Retrofit适用的call delegates（代理），Android平台默认使用ExecutorCallAdapterFactory，adapt返回ExecutorCallbackCall（即步骤4）</span></div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>详解 ServiceMethod serviceMethod = loadServiceMethod(method);</strong><br><strong>ServiceMethod整体思路：</strong> 内部主要是将方法中的注解取出，转换成HTTP Call的逻辑，暂且不深究。<br>下面看loadServiceMethod方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内部有缓存以提高性能，避免重复解析 - 使用LinkedHashMap来存储ServiceMethod，与接口中方法一一对应</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&gt; serviceMethodCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</div><div class="line"><span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">  ServiceMethod result;</div><div class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</div><div class="line">    <span class="comment">// 通过传入的方法，从Map中取出对应的ServiceMethod</span></div><div class="line">    result = serviceMethodCache.get(method);</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="comment">// 如果还没有实现，则构造一个ServiceMethod实例放入Map中</span></div><div class="line">      result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</div><div class="line">      serviceMethodCache.put(method, result);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong> 回到主线</strong>，retrofit.create()方法创建好实现类后，调用接口方法获得Call，前面步骤5已经说道，当接口方法被调用时候，会被拦截并且转换成HTTP Call。<br><strong>下面我们使用call进行enqueue操作：</strong>此处的call，即ExecutorCallbackCall，它有execute（同步）、enqueue（异步）两个方法，其中enqueue方法，可达到子线程请求，成功后切换回主线程的效果（原理 - 步骤4），免去了开启线程、使用handler跨线程通信的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Call&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt; call = api.defaultBenefits(<span class="number">20</span>, page++);</div><div class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt;() &#123;</div><div class="line">                <span class="comment">// 该处的onResponse方法已经转换到主线程上了，而转换关键在于Retrofit对象构建时，defaultAdapterFactory内部实现，见步骤2-&gt;步骤4</span></div><div class="line">                 <span class="meta">@Override</span></div><div class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt; call, Response&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt; response)</span> </span>&#123;</div><div class="line">                    ...</div><div class="line">                 &#125;</div><div class="line"></div><div class="line">                 <span class="meta">@Override</span></div><div class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;BaseModel&lt;ArrayList&lt;Benefit&gt;&gt;&gt; call, Throwable t)</span> </span>&#123;</div><div class="line">                    ...</div><div class="line">                 &#125;</div><div class="line">             &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Retrofit主线流程总结：</strong><br><strong>1. Retrofit对象的构建 - Retrofit.Builder()…build():</strong>①<strong>构建OkHttpClient</strong>，目前Retrofit仅支持OkHttpClient；②<strong>构建Executor</strong>：优先根据用户提供的callBackExcecutor来构建，若用户没有提供，则提供defaultCallbackExecutor（其<strong>内部会获取MainLooper构建handler，execute方法直接handler.post(runnable)，实现在主线程上的操作</strong>）；③<strong>使用executor来构建adapterFactories集合</strong>，优先将用户提供的adapterFactory加入到其中，再加上defaultCallAdapterFactory（传入②创建的callbackExecutor，defaultCallAdapterFactory内部持有OkHttpCall，在其enqueue方法中的onResponse方法调用defaultCallbackExecutor.execute方法，从而<strong>实现线程切换操作</strong>）；④最终使用<strong>Retrofit构造方法</strong>构建Retrofit实例对象</p>
<p><strong>2. Retrofit接口方法的实现方式 - retrofit.create(接口名.class)：</strong>①<strong>create方法创建并返回动态代理对象实例</strong>，动态代理对象内部会拦截接口方法的调用②<strong>动态代理内部通过ServiceMethod将接口方法适配成HTTP Call</strong>，再构造对应的OkHttpCall，最后通过CallAdapter转换成Retrofit适用的call delegate（ExecutorCallbackCall）。</p>
<p><strong>3. 使用动态代理(接口实现类)调用接口方法得到Call、使用call.enqueue进行异步请求：</strong>①调用接口方法时，动态代理对象（接口实现类）<strong>内部拦截</strong>；②<strong>调用call.enqueue</strong>，内部会调用ExecutorCallAdapter的enqueue方法，enqueue中onResponse方法调用defaultCallbackExecutor.execute方法，使用主线程Handler.post(runnable)从而<strong>实现线程切换操作</strong>。</p>
</li>
<li><strong>Retrofit主线流程总结图解（从上往下阅读）：</strong><br><img src="http://upload-images.jianshu.io/upload_images/1513860-c760c0ae59e266c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ol>
<h2 id="Retrofit源码深入探索（HOW-Part-2）"><a href="#Retrofit源码深入探索（HOW-Part-2）" class="headerlink" title="Retrofit源码深入探索（HOW - Part 2）"></a>Retrofit源码深入探索（HOW - Part 2）</h2><ol>
<li><p>retrofit.create()方法中一段令人疑惑的代码，却是<strong>Retrofit工作主要代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ①创建ServiceMethod，见深入探索步骤2</span></div><div class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line"><span class="comment">// ②传入ServiceMethod构造OkHttpCall，使用构造方法传入成员变量</span></div><div class="line">OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line"><span class="comment">// ③又将构造好的OkHttpCall传回，通过ServiceMethod中的callAdapter来进行转换，见步骤4</span></div><div class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>解析ServiceMethod：</strong>Adapts an invocation of an interface method into an HTTP call - 将接口中的方法适配成HTTP Call<br>loadServiceMethod内部通过Builder，build()方法创建：内部创建了CallAdapter（例：defaultCallAdapterFactory - 将Http Call 转成Retrofit中的Call-&gt;调用okHttp3.Call-&gt;线程切换）、Converter（请求结果转换器，例：Gson）、callFactory（okhttp3.Call.Factory - 对接okHttp）、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// callAdapter的创建</span></div><div class="line">      callAdapter = createCallAdapter();<span class="comment">//追踪代码可知：本质通过retrofit.nextCallAdapter方法创建，见步骤3</span></div><div class="line">      responseType = callAdapter.responseType();</div><div class="line">      ...</div><div class="line">      <span class="comment">// 创建ResponseConverter（转换器 - 对象与Http表示形式相互转换）</span></div><div class="line">      responseConverter = createResponseConverter();</div><div class="line"></div><div class="line">      <span class="comment">// 解析注解参数，逻辑不必深究</span></div><div class="line">      <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">        parseMethodAnnotation(annotation);</div><div class="line">      &#125;</div><div class="line">      ...</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"><span class="comment">// 构造方法，内部参数基本都由Retrofit提供</span></div><div class="line">ServiceMethod(Builder&lt;R, T&gt; builder) &#123;</div><div class="line">    <span class="comment">// 负责创建HTTP请求，一个可以执行的HTTP请求（okHttp3.Call），仅支持OkHttpClient</span></div><div class="line">    <span class="keyword">this</span>.callFactory = builder.retrofit.callFactory();</div><div class="line">    <span class="comment">// 将Retrofit中的Call&lt;T&gt;转为T（Retrofit中的Call ≠ okHttp中的Call，前者表示retrofit接口方法调用，内部通过后者实现，最后通过）</span></div><div class="line">    <span class="keyword">this</span>.callAdapter = builder.callAdapter;<span class="comment">// 将响应类型适配成用户指定的类</span></div><div class="line">    <span class="keyword">this</span>.responseConverter = builder.responseConverter;<span class="comment">// 对象与Http表示形式相互转换的转换器</span></div><div class="line">    <span class="keyword">this</span>.parameterHandlers = builder.parameterHandlers;<span class="comment">// 解析接口注解参数</span></div><div class="line">    ...<span class="comment">// 略去非重点关注成员变量</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>CallAdapter的创建：</strong>遍历adapterFactories，找到并返回合适的adapter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,</div><div class="line">      Annotation[] annotations) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">//  遍历adapterFactories，找到可以接收指定类型的adapter</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">      <span class="comment">// 通过get方法，获得相匹配的类型</span></div><div class="line">      CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</div><div class="line">      <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 找到合适adapter，返回</span></div><div class="line">        <span class="keyword">return</span> adapter;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//下面看看一般的adapterFactories源码</span></div><div class="line"><span class="comment">//1、ExecutorCallAdapterFactory中的get方法</span></div><div class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">    <span class="comment">// 如果返回类型为Call类型，则使用它</span></div><div class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//2、RxJavaCallAdapterFactory、RxJavaCallAdapterFactory中的get方法是Observable类型（源码略显复杂掠过）</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>解析serviceMethod.callAdapter.adapt方法：</strong>因callAdapter类型而异，ExecutorCallAdapterFactory适配的是ExecutorCallbackCall类型，而RxJava适配的是Observable类型<br><strong>注意：</strong>无论是什么类型的callAdapter，最终都会调用OkHttpCall中的enqueue、execute方法，把实际的工作交给OkHttp来做，详见步骤5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ExecutorCallAdapterFactory</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">      &#125;</div><div class="line"><span class="comment">// RxJavaCallAdapter</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</div><div class="line">    OnSubscribe&lt;Response&lt;R&gt;&gt; callFunc = <span class="keyword">new</span> CallOnSubscribe&lt;&gt;(call);</div><div class="line"></div><div class="line">    OnSubscribe&lt;?&gt; func;</div><div class="line">    <span class="comment">// 构造订阅者func逻辑，省略...</span></div><div class="line">    <span class="comment">// 通过func构造Observable</span></div><div class="line">    Observable&lt;?&gt; observable = Observable.create(func);</div><div class="line">    <span class="comment">// Observable配置逻辑，省略...</span></div><div class="line">    <span class="keyword">return</span> observable;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>解析OkHttpCall调用链：</strong>OkHttp的包装类，与OkHttp对接，实现了Retrofit中的Call接口，内部使用OkHttp框架来进行实际操作，解析好数据后再调用传入的callbackA -(内部通过Execute实现线程切换)-&gt;调用用户传入的callbackInMainThread（漫长的一个调用链..）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 从上面分析可知，调用接口定义方法返回ExecutorCallbackCall        </span></div><div class="line"> <span class="comment">// call.enqueue(callbackInMainThread);  调用其enqueue方法，内部持有OkHttpCall 作为 delegate</span></div><div class="line"><span class="comment">// 将callbackInMainThread包裹executor实现线程切换，生成callbackA</span></div><div class="line"><span class="comment">// delegate.enqueue(callbackA); 上面的方法内部会调用delegate.enqueue方法以对接OkHttp框架</span></div><div class="line"><span class="comment">// 下面看OkHttpCall的enqueue方法（OkHttp框架里的方法，与Retrofit无关）</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</div><div class="line">     ...</div><div class="line">    okhttp3.Call call;</div><div class="line">    ...</div><div class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span></span></div><div class="line">          <span class="keyword">throws</span> IOException &#123;</div><div class="line">        Response&lt;T&gt; response;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// onResponse时候进行数据转换，关键点：Converter （下方附有调用链）</span></div><div class="line">          response = parseResponse(rawResponse);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">          callFailure(e);</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        callSuccess(response);</div><div class="line">      &#125;</div><div class="line">        ...</div><div class="line">    <span class="comment">// 请求失败调用callbackA.onFailure -(内部线程切换)-&gt; callbackInMainThread.onFailure</span></div><div class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    <span class="comment">// 响应成功调用callbackA.onResponse -(内部线程切换)-&gt; callbackInMainThread.onSuccess或onFailure</span></div><div class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callSuccess</span><span class="params">(Response&lt;T&gt; response)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="comment">// 数据转换调用链：parseResponse -(关键调用)-&gt; serviceMethod.toResponse -&gt; GsonRequestBodyConverter.convert</span></div><div class="line"> <span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">      ...</div><div class="line">      T body = serviceMethod.toResponse(catchingBody);</div><div class="line">      ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Retrofit中的设计模式，解耦方式（WHY）"><a href="#Retrofit中的设计模式，解耦方式（WHY）" class="headerlink" title="Retrofit中的设计模式，解耦方式（WHY）"></a>Retrofit中的设计模式，解耦方式（WHY）</h2><p>Retrofit中涉及不少的设计模式，笔者能力有限，设计模式方面知识储备不足，仍需继续努力，这里暂且给出设计模式定义与链接，作初步认识。</p>
<h3 id="门面模式（Facade-Pattern）"><a href="#门面模式（Facade-Pattern）" class="headerlink" title="门面模式（Facade Pattern）"></a>门面模式（Facade Pattern）</h3><p>Retrofit - retrofit.create()<br><strong>定义：</strong>外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。门面模式又称为外观模式，它是一种对象结构型模式。<br><strong>传送门：</strong><a href="http://blog.csdn.net/xingjiarong/article/details/50066133" target="_blank" rel="external">xingjiarong - 门面模式</a></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Retrofit中的三大工厂 - okhttp3.Call.Factory，CallAdapter.Factory 和 Converter.Factory<br><strong>定义</strong>：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式（同属于创建型模式的还有工厂方法模式，抽象工厂模式，单例模式，建造者模式）。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。<br><strong>传送门：</strong><a href="http://blog.csdn.net/xingjiarong/article/details/49999121" target="_blank" rel="external">xingjiarong - 简单工厂模式</a>、<a href="http://blog.csdn.net/xingjiarong/article/details/50051265" target="_blank" rel="external">xingjiarong - 抽象工厂模式</a></p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>ExecutorCallbackCall类：在源“OkHttpCall”操作时，进行线程切换操作<br><strong>定义：</strong>动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。<br><strong>传送门：</strong><a href="http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html" target="_blank" rel="external">design-patterns - 装饰模式</a></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>ExecutorCallbackCall中的delegate的动态设置，从而针对不同代理采用不同方法<br><strong>定义：</strong>给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。<br><strong>传送门：</strong><a href="http://www.jianshu.com/p/6f6bb2f0ece9" target="_blank" rel="external">xiazdong - 代理模式及Java实现动态代理</a></p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>CallAdapter，各种适配器，将一个东西适配成一个适合我们使用的东西<br><strong>定义：</strong>适配器模式将一个类的接口，转化成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。<br><strong>传送门：</strong><a href="http://blog.csdn.net/xingjiarong/article/details/50146615" target="_blank" rel="external">xingjiarong - 适配器模式</a></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>CallAdapter内部还夹杂着策略模式？<br><strong>定义：</strong>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。<br><strong>传送门：</strong><a href="http://blog.csdn.net/xingjiarong/article/details/50168853" target="_blank" rel="external">xingjiarong - 策略模式</a>、<a href="http://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html" target="_blank" rel="external">design-patterns - 策略模式</a></p>
<p><strong>Stay的详细分析：</strong><a href="http://www.jianshu.com/p/fb8d21978e38" target="_blank" rel="external">Retrofit分析-经典设计模式案例</a></p>
<h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul>
<li><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Stay - Retrofit分析 - 漂亮的解耦套路</a></li>
<li><a href="http://www.stay4it.com/course/22" target="_blank" rel="external">Stay - Retrofit分析 - 漂亮的解耦套路(视频版)</a></li>
<li><a href="http://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">Piasy - 拆轮子系列：拆Retrofit</a></li>
<li><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" target="_blank" rel="external">android-cn - Retrofit源码解析</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> 拆轮子笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[针对Android重新认识OOP]]></title>
      <url>http://yoursite.com/2017/01/08/%E9%92%88%E5%AF%B9Android%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86OOP/</url>
      <content type="html"><![CDATA[<h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><ul>
<li>OOP基本概念</li>
<li>认识对象Object</li>
<li>类Class</li>
<li>&lt;基类/子类&gt;结构</li>
<li>主动型与被动型API<a id="more"></a></li>
</ul>
<h2 id="几个字尾的基本概念"><a href="#几个字尾的基本概念" class="headerlink" title="几个字尾的基本概念"></a>几个字尾的基本概念</h2><h3 id="“-Oriented”含义"><a href="#“-Oriented”含义" class="headerlink" title="“-Oriented”含义"></a>“-Oriented”含义</h3><ul>
<li>“-Oriented”翻译，导向的，定向的</li>
<li>“Object-oriented”相信所有程序都是由对象构成的</li>
<li>综上，开发时，写代码，心中需要有面向对象的信仰，写各种class实现需求。</li>
</ul>
<h3 id="“-Based”含义"><a href="#“-Based”含义" class="headerlink" title="“-Based”含义"></a>“-Based”含义</h3><ul>
<li>“-Based”翻译，根基，以…为基础</li>
<li>“Requirement-based”基于需求，有先后的顺序。简单来说，就是先进行需求分析，基于分析得到的结果，再进行后续的开发活动。</li>
</ul>
<h3 id="“-Driven”含义"><a href="#“-Driven”含义" class="headerlink" title="“-Driven”含义"></a>“-Driven”含义</h3><ul>
<li>“-Driven”翻译，引导，受到驱策的（不是驱动）</li>
<li>“Model-driven”开发之前，先制定一个模型（为开发引导方向），不违背该模型前提下，进行实际开发活动</li>
<li>“Use Case-driven”以用户的使用需求为方向，进行开发。</li>
</ul>
<h3 id="“-Centered”含义"><a href="#“-Centered”含义" class="headerlink" title="“-Centered”含义"></a>“-Centered”含义</h3><ul>
<li>“-Centered”翻译，围绕…为中心</li>
<li>“Architecture-centered”一切开发活动都围绕架构，就像在一颗圣诞树上挂灯饰。</li>
</ul>
<h2 id="重新认识对象（Object）"><a href="#重新认识对象（Object）" class="headerlink" title="重新认识对象（Object）"></a>重新认识对象（Object）</h2><p><strong>OOP思想中，我们所认识的一切东西，都是对象（Object）</strong></p>
<h3 id="如何才能算认识？"><a href="#如何才能算认识？" class="headerlink" title="如何才能算认识？"></a>如何才能算<strong>认识</strong>？</h3><p>能够说出其特点并能与其他对象进行比较，而特点包括：</p>
<ol>
<li>对象的特征或者属性</li>
<li>对象的行为</li>
</ol>
<h3 id="面向对象什么意思？"><a href="#面向对象什么意思？" class="headerlink" title="面向对象什么意思？"></a>面向对象什么意思？</h3><p>相信我们身边的一切，都是有相应的class与之对应</p>
<h3 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h3><ol>
<li>自然界中，鸟的特征：有翅膀，有眼睛；鸟的行为，鸣叫，飞行。</li>
<li>代码界中，对象是由数据（Data）与函数（Function）组成。</li>
</ol>
<h2 id="类的用途-叙述软件对象"><a href="#类的用途-叙述软件对象" class="headerlink" title="类的用途 - 叙述软件对象"></a>类的用途 - 叙述软件对象</h2><p>类（Class）是群体（或集合），而对象是类的一个个体，需要明白<strong>对象与类的关系</strong>。<br>类是一群具有<strong>共同重要特性</strong>的对象。类的定义即是说明这群对象有什么重要的特性（包括对象的特征及其行为），而软件中，对象以数据来表达特征，以函数来表达行为。</p>
<p>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</div><div class="line">	<span class="comment">//特征描述（运用数据来描述）</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="comment">//行为描述（方法描述）</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</div><div class="line">	System.out.println(<span class="string">"My name is"</span>+name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="comment">//此时，new People()指令会产生一个People对象</span></div><div class="line">	<span class="comment">//执行时候，会使用上面定义People的模型，去创建一个people实例</span></div><div class="line">	<span class="comment">//这样，电脑内部就会有一个对象与自然界的People对应了</span></div><div class="line">	People people = <span class="keyword">new</span> People();</div><div class="line">	<span class="comment">//让该对象执行它的行为，那么电脑就会根据上面定义的行为描述去执行</span></div><div class="line">	people.say();</div></pre></td></tr></table></figure></p>
<p>另外，<strong>实例（Instance）</strong>：与对象含义相近似，而在计算机角度，实例偏向于，开辟了的存储空间。</p>
<h2 id="lt-基类-子类-gt-结构用途"><a href="#lt-基类-子类-gt-结构用途" class="headerlink" title="&lt;基类/子类&gt;结构用途"></a>&lt;基类/子类&gt;结构用途</h2><p><strong>继承（Inheritance）：</strong>子类会继承父类的所有特性（特征以及其行为），也可以理解成子类是父类的扩展的一种形式。</p>
<p>对众多对象分门别类之后，可以形成一个继承体系。</p>
<p><img src="http://img.blog.csdn.net/20160215224927567" width="400" height="200"></p>
<p>可以这么看，Person是一个大的集合，而Teacher、Student因为自身拥有独特的特性（在满足人全部特性的前提下，老师需要教书这一行为，而学生需要做作业这一行为），所以它们是大集合中的一部分，也就是子集。</p>
<p>而定义子类时候，使用关键字“extends”，这翻译过来正是扩展的意思，也就是在父类的基础上再拓展自己独特的部分。</p>
<p>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>继承的是父类的定义，而不是继承父类的定义项的具体数值。例如，父亲类年龄项，然后有个父亲对象年龄被设置成30，儿子类继承父亲类后，继承的是年龄项的这个定义，而与它后来被设置的具体数值是没有关联的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//注意这种情况，如果父亲类定义时候已经设置了具体数值，那么，儿子类继承之后当然也就继承下来了</div><div class="line">//因为，这个具有具体数值的定义项一并成为了父亲类的一个特征，所以儿子类当然也会具有这个特征</div><div class="line">public class Father30&#123;</div><div class="line">		public int age = 30;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public class Son extends Father30&#123;</div><div class="line">	public void sayAge()&#123;</div><div class="line">		System.out.println(&quot;年龄：&quot;+age);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class main &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Son son = new Son();</div><div class="line">		son.sayAge();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">//输出：“年龄：30”</div></pre></td></tr></table></figure>
<h2 id="Android中的-lt-基类-子类-gt-结构"><a href="#Android中的-lt-基类-子类-gt-结构" class="headerlink" title="Android中的&lt;基类/子类&gt;结构"></a>Android中的&lt;基类/子类&gt;结构</h2><p>Android本身就提供许多完整的框架基类，而我们大多数情况下的开发，都基于框架上，继承相关类并做出相应的扩展，从而实现需求。</p>
<p>例如：View继承框架（部分）<br><img src="http://img.blog.csdn.net/20160216004901906" width="400" height="300"></p>
<p><strong>类与类的组合关系：</strong>接口（interface）与实现类的关系（implements），接口会定义一个<strong>等待实现</strong>的方法，实现类需要实现接口定义的方法，换一种说法，接口定义了一种格式，而实现类需要符合这种格式才能与接口对接（implements），就像电脑的USB接口，那么U盘就必须要有一个与这个接口相匹配的对接处才能接上电脑。</p>
<p><strong>例如：</strong>Java中，提供了一个Thread基类和一个Runnable接口，那么这两个元素构成了一个框架。Thread基类有一个start方法，而Runnable接口有一个run方法。那么如何使用这个框架？Thread类需要传入一个Runnable接口的实现类，那么，就需要构造一个Runnable接口实现类。上述过程可以想像成，你需要打开U盘里面的一个文件（Thread.start();），首先你要接入U盘(传入一个Runnable接口实现类)，而你需要这个U盘是一个能够符合USB规格的U盘才能接入（需要构造一个实现Runnable接口的实现类），而且你还需要保证U盘里面有你想要的文件（也就是根据需求，实现run方法）。</p>
<p><strong>综上：</strong>这个框架工作原理就是，Thread基类先创建一个小线程，然后该线程通过Runnable接口，呼叫实现类实现后的run方法。<br>现在，换一种方式来思考，Thread类与Runnable接口，直接看的话，看似没有什么关系，但是通过理解上面的工作原理，那么就可以这么认为了：把Runnable塞入Thread中（就像把USB接口镶嵌在笔记本电脑上），然后Thread就看成一个抽象函数（不是真的是抽象函数，只是从结构上认为），而实现类的方法会覆盖掉Thread类中的run抽象方法，这样就变成了实现类是Thread类的子类了（注意，两者不是继承关系）。</p>
<p>原本的结构：<br><img src="http://img.blog.csdn.net/20160216014132380" width="500" height="300"></p>
<p>将Runnable塞入Thread中后的结构：<br><img src="http://img.blog.csdn.net/20160216014048046" width="500" height="300"></p>
<p>那么，这样不就是基类子类的结构关系了吗？<br>也说明了组合关系可以变成这样一个基类子类的关系。</p>
<p><strong>这样可以得出一个结论：</strong><br>基类子类的结构可以呈现两种意义：</p>
<ol>
<li>继承关系</li>
<li>组合关系</li>
</ol>
<p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//此时extends的扩展的意思，而不是继承，而继承是扩充的一种</div><div class="line">//因为run方法一定要覆盖掉才能在JMain中如此使用</div><div class="line">class Task extends Thread｛</div><div class="line">	public void run()&#123;</div><div class="line">		//根据需求实现线程功能</div><div class="line">	&#125;</div><div class="line">｝</div><div class="line"></div><div class="line">public class JMain｛</div><div class="line">	public static void main(String [] args)&#123;</div><div class="line">		Thread t = new Task();</div><div class="line">		//Task t = new Task(); 或者这么写</div><div class="line">		t.start();</div><div class="line">	&#125;</div><div class="line">｝</div></pre></td></tr></table></figure></p>
<p>工作原理，即基类子类工作原理：<br>new子类（Task）时候，会自动new基类（Thread）的对象，而run方法又被Task实现了，所以能如此使用</p>
<h2 id="lt-基类-子类-gt-结构的接口"><a href="#lt-基类-子类-gt-结构的接口" class="headerlink" title="&lt;基类/子类&gt;结构的接口"></a>&lt;基类/子类&gt;结构的接口</h2><p>卡榫函数（Hook函数） - 指的是接口中的方法函数，起结合基类与子类，实现PnP(Plug and Play)的作用，所谓PnP，通俗来讲，就是能够自由地接上，拔下，自由更换的意思，能够跨平台适用。</p>
<p>以<strong>Template Method设计模式</strong>为例<br><img src="http://img.blog.csdn.net/20160229232658184" width="400" height="300"></p>
<p>AbstractClass（基类）通过两个Hook函数与子类相连接，原理：ConcreateClass（子类）重写了Hook函数，从而使基类与子类建立了关联，基类在调用这两个Hook函数时候会调用子类重写的两个方法。</p>
<p><strong>卡榫函数（Hook函数）及应用框架之基本原则</strong>：将变化的（Variant）与不变化的（Invariant）分离，一般而言，分离之后将不变的部分写在父类中，变化的部分写在子类中，而其目的就是为了让基类可以被复用。</p>
<p><strong>IoC机制</strong>（Inversion of Control），继承体系中，基类函数可以主动调用子类函数（反向），而子类函数调用基类函数则是（正向）<br>，而基类函数主动调用子类函数正是典型的IoC机制。<br>基类与子类间，控制权在基类上（因为可以通过Hook函数调用子类函数），因为通常基类先写而子类后写，基类（前辈）拥有控制权控制子类（后辈）的情况，称作<strong>控制反转</strong>。</p>
<ul>
<li>默认行为（Default函数）<br>基类有一个重要功能：可事先定义一定量的默认（预设）行为供子类继承或者调用。</li>
</ul>
<h2 id="主动型与被动型API"><a href="#主动型与被动型API" class="headerlink" title="主动型与被动型API"></a>主动型与被动型API</h2><p><strong>首先通过例子来进行初步了解：</strong><br><img src="http://img.blog.csdn.net/20160301011953946" width="400" height="300"><br>解析：</p>
<ol>
<li><strong>基类</strong>通过Hook函数调用子类具体函数这种IoC机制的调用形式称做<strong>主动型API</strong></li>
<li>子类正向调用基类，站在<strong>基类</strong>角度，是被调用的，因此称为<strong>被动型API</strong></li>
</ol>
<p>也就是说，主要是在<strong>基类的角度</strong>来区分两者的。</p>
<ol>
<li>由基类定义并实现某个方法，而由子类来调用，即是被动型API</li>
<li>由基类定义某个方法，而由子类来实现，最终由基类本身来调用该方法，即是主动型API（实现该种方法弹性更高，设计更科学）</li>
</ol>
<p><strong>历史上的一些应用？</strong></p>
<ol>
<li><p>先举一个<strong>反例</strong>，1990年代初，Orbix 系统使用了被动型API，子类调用基类定义并实现的方法，当子类越来越多的时候，那么被调用的基类的方法就被固定死了，因为稍有改动就会影响到全部调用它的子类，这里子类指应用程序，而基类指系统。主动权在子类上，因此该系统不久就走向了灭亡。<br><img src="http://img.blog.csdn.net/20160301170109050" width="400" height="300"></p>
</li>
<li><p>Windows 系统采用了主动型API，95年时采用COM/DCOM框架定义了一个接口，而应用程序则需要实现这样一个接口，最后被该系统框架调用，控制权在系统中；<br><img src="http://img.blog.csdn.net/20160301173620212" width="400" height="300"></p>
</li>
<li><p>2001年改进后采用了.NET框架，建立了基类子类结构，而COM/DCOM额外定义了接口，没有基类子类的结构；.NET框架通过Hook函数与应用程序相连接，实现IoC机制，系统掌握全部控制权；但其中也有被动型API，但需要在调用主动型API的前提下才能调用被动型API。<br><img src="http://img.blog.csdn.net/20160301173649268" width="400" height="300"></p>
</li>
</ol>
<p>因此，API十分重要，接口（Interface）是连接的关键，拥有接口的控制权，则拥有了主导的地位</p>
<h3 id="Android中的API范例"><a href="#Android中的API范例" class="headerlink" title="Android中的API范例"></a>Android中的API范例</h3><p><strong>Activity：</strong><br>开发过程中，能够实现各种各样的功能与效果，看似很自由，实际上，我们都是在根据需求来实现一些系统接口，而这些接口正是掌握在Google定义的Activity基类中，再仔细看。</p>
<p><strong>onCreate方法为例</strong><br>实现原理：Activity基类先调用onCreate方法接口，而onCreate这个接口又连接到UserActivity（开发者写的Activity）子类中的onCreate方法。<br>即：onCreate这个接口是Activity基类定义的，再通过UserActivity子类实现，最后由Activity基类调用UserActivity的具体实现。</p>
<ul>
<li>再看onClickListener的onClick方法，由基类OnClickListener来定义，由App开发者来实现，最后由OnClickListener基类来调用。Android中主动型API处处可见。</li>
</ul>
<h3 id="总结，接口与类"><a href="#总结，接口与类" class="headerlink" title="总结，接口与类"></a>总结，接口与类</h3><p>OOP中，将接口定义为一种特殊的类。因为OOP中，一切都是由类构成的。<br>C++中类别有三种:</p>
<ol>
<li>具象类（所有函数都是有具体实现的）</li>
<li>抽象类（有一个或者多个函数是抽象的）</li>
<li><strong>纯粹抽象类</strong>（全部函数都是抽象的，而Java中将该类别称为<strong>接口-Interface</strong>）</li>
</ol>
<p><strong>IoC机制在Java中的实现</strong>（也就是我们最常用的使用<strong>接口实现类</strong>）<br><strong>以Runnable接口为例</strong><br>直接来看，Task与Thread是通过Runnable接口来进行关联的，并不存在基类子类的关系，但是因为Thread的构造方法需要传入一个Runnable接口的实现类，可以认为Thread类内部有一个Runnable接口，再将Runnable接口中的run方法放入Thread类中，而Task实现了Thread定义的run方法，那么Thread与Task的基类子类关系就成立了。</p>
<p><strong>IoC机制</strong>代码简单实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Task implments Runnable&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		//...</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class JMain&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">	Thread t = new Thread(new Tasks());</div><div class="line">	t.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="学习资源推荐"><a href="#学习资源推荐" class="headerlink" title="学习资源推荐"></a>学习资源推荐</h2><p>Android从程序员到架构师之路系列视频 - 高焕堂；</p>
]]></content>
      
        
        <tags>
            
            <tag> 设计思想 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android进阶 - 消息处理机制探索]]></title>
      <url>http://yoursite.com/2017/01/04/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android消息机制，是Android中核心机制之一，进阶路上的基础知识，其主要指的是Handler运行机制，而<strong>Handler运行需要底层的MessageQueue、Looper的支撑</strong>，下面我们共同探索。<a id="more"></a></p>
<h2 id="核心概念综述"><a href="#核心概念综述" class="headerlink" title="核心概念综述"></a>核心概念综述</h2><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>对于Handler，许多初学者认为它基本用于更新UI。<br>而官方解析道：<br><em>There are two main uses for a Handler:<br> (1) to schedule messages and runnables to be executed as some point in the future;<br> (2) to enqueue an action to be performed on a different thread than your own.</em><br>翻译过来：<br><strong> (1) 调度message、runnable的执行<br> (2) 使动作在不同的线程中执行。</strong><br>其并没有提及更新UI的作用，从本质上看，Handler并不是专门用来更新UI的，只是对于开发者来说，它常被用于更新UI，实际Handler是Android消息机制的一个重要组成部分，更新UI不过是消息传递与处理的其中一部分。</p>
<h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>代表一个行为或是一串动作，每一个消息加入消息队列时，都有明确的Handler作为目标。</p>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>字面意思 - 消息队列，以队列形式对外提供插入、删除工作，但内部以<strong>单链表</strong>存储结构实现，并<strong>不是真正的队列</strong>，而是采用单链表的数据结构来存储消息列表。</p>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>消息循环，Looper会以无限循环形式去MessageQueue查找是否有新消息，如果有则处理，没有则等待。<br><strong>注意：</strong></p>
<ol>
<li><strong>线程中默认没有Looper，如果使用Handler就必须为线程创建Looper。</strong>创建Handler之前，需要Looper.prepare()，最后要补上Looper.loop();</li>
<li>主线程（UI线程），ActivityThread创建时已经初始化Looper了，故可以直接使用</li>
</ol>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>Handler创建时候需要获取到当前线程中的Looper来构造消息循环系统，Handler内部正是通过ThreadLocal来获取的。<br>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。<br>详解可参见：<a href="http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/" target="_blank" rel="external">解密ThreadLocal</a></p>
<h2 id="消息机制流程解析"><a href="#消息机制流程解析" class="headerlink" title="消息机制流程解析"></a>消息机制流程解析</h2><h3 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h3><p>创建 Handler时，会获取当前线程的Looper来构建消息循环系统，如果当前线程没有Looper，则会报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Handler无参构造方法（部分）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">   ...</div><div class="line">	<span class="comment">//从sThreadLocal中取出当前对象的Looper</span></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">	<span class="comment">//检查Looper是否为空</span></div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Handler创建完毕后，内部的Looper以及MessageQueue就可以与Handler一起协同工作了，Handler通过post投递Runnable或者send方法发送消息（post方法最终也是通过send方法来完成的），Runnable与Message最终都会交给Looper中处理。</p>
<p><strong>Send方法流程：</strong>通过MessageQueue的enqueueMessage方法将消息放入消息队列，Looper发现有新消息到来，则处理该消息。最终消息中的Runnable或者HandlerMessage方法会被调用。<br><strong>注意: </strong></p>
<ol>
<li>Looper运行在Handler所在线程中的，当消息交给Looper处理时候，业务逻辑已经成功切换到创建Handler所在的线程中了。</li>
<li>每个线程都至多只可以有一个Looper对象，也只可以有一个与该Looper对象关联的MessageQueue对象。</li>
<li>每个线程可以有多个Handler对象，Looper将Message取出来后，会调用与该Message关联的Handler的dispatchMessage方法。</li>
</ol>
<p><strong>下面引用一张关系来阐述：</strong><br><img src="http://odzvmv4ab.bkt.clouddn.com/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%85%B3%E7%B3%BB%E7%AE%80%E5%9B%BE.jpg" alt=""><br><strong>解析： </strong></p>
<ul>
<li>Runnable和Message可以被压入某个MessageQueue。而需要注意的是，某种类型的MessageQueue一般只允许保存相同类型的Object</li>
<li>实际上，源码中会对Runnable进行相应处理，转换成Message再放入到对应MessageQueue中</li>
</ul>
<p><strong>流程总结：</strong></p>
<ol>
<li>Handler创建时，通过sThreadLocal取出当前对象的Looper构建消息循环系统，若当前线程没有Looper则报错</li>
<li>Handler通过post或send方法将Runnable投递或者Message发送，Message入队到MessageQueue，同时Looper死循环查看MessageQueue是否有消息，不断取出新消息，交给对应Handler处理。（取出消息的时，内部实现了跨线程通信）</li>
<li><strong>即：Looper不断获取MessageQueue中的一个Message，然后由Handler来处理</strong></li>
</ol>
<h2 id="深入理解-源码探究"><a href="#深入理解-源码探究" class="headerlink" title="深入理解 - 源码探究"></a>深入理解 - 源码探究</h2><h3 id="消息机制相关类联系"><a href="#消息机制相关类联系" class="headerlink" title="消息机制相关类联系"></a>消息机制相关类联系</h3><ol>
<li>Thread - Looper  1对1，一个Thread最多只能拥有一个Looper</li>
<li>Looper - MessageQueue  1对1，一个Looper只能对应一个MessageQueue</li>
<li>MessageQueue - Message  1对N，一个MessageQueue中有N个Message</li>
<li>Message - Handler  N对1，每个Message最多指定一个Handler</li>
<li>Thread - Handler  1对N，由上述关系推断</li>
</ol>
<p><strong>相关类的类关系图：</strong><br><img src="http://odzvmv4ab.bkt.clouddn.com/Thread%E4%B8%8EHandler%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt=""></p>
<h3 id="Handler-1"><a href="#Handler-1" class="headerlink" title="Handler"></a>Handler</h3><p>源码路径：frameworks/base/core/java/android/os/Handler.java<br>Handler功能一 - <strong>处理Message（本职工作）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//相关函数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span></span>;<span class="comment">//对Message进行分发</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;<span class="comment">//对Message进行处理</span></div><div class="line"><span class="comment">//源码-----------------------------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断消息是否携带callback（Runnable对象）</span></div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//消息携带callback，则直接执行callback</span></div><div class="line">        handleCallback(msg);<span class="comment">//方法实质：msg.callback.run();</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">//判断Handler.mCallback（Runnable对象）是否为空</span></div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">//使用自带的mCallback处理</span></div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">		<span class="comment">//消息没有携带callback，handler自身也没有mCallback才调用</span></div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Subclasses must implement this to receive messages.</div><div class="line"> * 子类必须实现该方法去接收msg</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>Looper从MessageQueue中取出一个Message后，首先会调用dispatchMessage方法进行消息派发</li>
<li>dispatchMessage方法会根据具体策略来将Message分发给相应负责类处理（上述源码中为默认处理方式）</li>
<li>Handler的扩展子类可以重写上述两个方法来改变它的默认行为</li>
</ol>
<p>Handler功能二 - <strong>将Message压入MessageQueue</strong><br>注意：该功能的设计形成了一个<strong>神奇的“循环圈”</strong>，熟悉类关系图（见上文），便很好理解了：<br>Handler -(压入消息)-&gt; MessageQueue -(Looper取出消息)-&gt; Message -(传递消息给Handler处理)-&gt; Handler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//相关函数（部分）</span></div><div class="line"><span class="comment">//Post:</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></div><div class="line">...</div><div class="line"><span class="comment">//Send:</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span></div><div class="line">...</div><div class="line"><span class="comment">//源码（部分）-------------------------------------------------------</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></div><div class="line">   &#123;</div><div class="line">	<span class="comment">//Post内部调用Send，需要先把Runnable转成Message</span></div><div class="line">	<span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将Runnable转成Message的主要方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="comment">/*Android系统内部维护一个全局Message池，当用户需要用Message时，</span></div><div class="line">        通过Message.obtain直接获取即可，避免创建，节约资源*/</div><div class="line">		Message m = Message.obtain();</div><div class="line">		<span class="comment">//转换实质：将Runnable对象设置成Message的callback(回调函数)</span></div><div class="line">        m.callback = r;</div><div class="line">        <span class="keyword">return</span> m;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 准备好Msg，发送消息，实现delay逻辑后，调用sendMsgAtTime</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">            delayMillis = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 实质发消息的方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">	<span class="comment">//一般每个Thread都会有一个MessageQueue来承载消息</span></div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//没有Queue则抛异常</span></div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//压入MQ</span></div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="MessageQueue-1"><a href="#MessageQueue-1" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>源码：frameworks/base/core/java/android/os/MessageQueue.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造方法</span></div><div class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</div><div class="line">    mQuitAllowed = quitAllowed;</div><div class="line">	<span class="comment">//本地创建一个NativeMessageQueue对象并赋值给mPtr(long类型)</span></div><div class="line">    mPtr = nativeInit();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//本地方法（C++实现）</span></div><div class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</div><div class="line">	<span class="comment">//创建NativeMessageQueue对象</span></div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</div><div class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</div><div class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    nativeMessageQueue-&gt;incStrong(env);</div><div class="line">	<span class="comment">//返回地址</span></div><div class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</div><div class="line">&#125;</div><div class="line"><span class="comment">//对应的销毁本地方法</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeDestroy</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</div><div class="line">    nativeMessageQueue-&gt;decStrong(env);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//主要方法声明</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span><span class="comment">//入队</span></span></div><div class="line">Message <span class="title">next</span><span class="params">()</span><span class="comment">//出队</span></div><div class="line"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span><span class="comment">//删除元素</span></div><div class="line"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, Runnable r, Object object)</span></div></pre></td></tr></table></figure></p>
<h3 id="Looper-1"><a href="#Looper-1" class="headerlink" title="Looper"></a>Looper</h3><p>源码路径：frameworks/base/core/java/android/os/Looper.java<br><strong>Android源码角度</strong>上看，消息机制设计思想更贴近下图：<br><img src="http://odzvmv4ab.bkt.clouddn.com/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AE%9E%E9%99%85%E6%80%9D%E6%83%B3%E5%9B%BE.jpg" alt=""><br>解析：从上文类关系图可知，Looper含有mQueue、mThread，Handler含有mQueue、mLooper，MessageQueue含有mMessages。这样，图就简化成Looper与Handler（其实还有Thread）之间的关系了。</p>
<p><strong>Looper在普通线程中的工作过程：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//举个一般的使用栗子</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> Handler mHandler;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Looper.prepare();</div><div class="line">            mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                    <span class="comment">//通常需要重写该方法来处理消息</span></div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Looper.loop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>解析：</strong><br>上述代码关键有三个步骤：</p>
<ol>
<li>Looper.prepare(); - Looper的准备工作</li>
<li>创建处理消息的Handler</li>
<li>Looper.loop(); - Looper的开始运作</li>
</ol>
<p><strong>步骤一 - Looper.prepare()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div><div class="line"></div><div class="line"> <span class="comment">/** Initialize the current thread as a looper.</span></div><div class="line">  * This gives you a chance to create handlers that then reference</div><div class="line">  * this looper, before actually starting the loop. Be sure to call</div><div class="line">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</div><div class="line">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//prepare实质工作就是</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">	<span class="comment">//保证Looper在某个Thread的唯一存在</span></div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//将Looper保存到sThreadLocal</span></div><div class="line">	<span class="comment">//（ThreadLocal下面再详细阐述，这里只要知道：其主要作用是为每个Thread互不干扰保存独有的数据即可）</span></div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//构造方法，构建MQ、获取当前Thread</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>步骤二 - 创建处理消息的Handler</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Handler重要成员变量，具有多个初始化以下成员变量的构造方法</span></div><div class="line"><span class="keyword">final</span> MessageQueue mQueue;</div><div class="line"><span class="keyword">final</span> Looper mLooper;</div><div class="line"><span class="keyword">final</span> Callback mCallback;</div><div class="line"></div><div class="line"><span class="comment">//Handler构造逻辑</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断是否潜在内存泄漏，报警告</span></div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//本质通过sThreadLocal.get()得到</span></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//从Looper中得到，mQueue担当Looper与Handler之间沟通的桥梁</span></div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>步骤三 - Looper.loop()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="comment">//获取当前Looper（即sThreadLocal.get()获得的Looper）</span></div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//获取Looper中的MQ</span></div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">    <span class="comment">//确保当前线程的id与本地进程相一致，保持追踪实际id（翻译自官方文档，非本文讨论重点，可忽略）</span></div><div class="line">	Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">		<span class="comment">//开启消息死循环</span></div><div class="line">        Message msg = queue.next(); <span class="comment">// 取出消息，可能会阻塞</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//没有消息则退出循环</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">		...</div><div class="line">        msg.target.dispatchMessage(msg);<span class="comment">//调用Handler中的dispatchMessage分发消息，target本质为Handler</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">		<span class="comment">//确保id在分发消息过程中不发生错误变化（翻译自官方文档，非本文讨论重点，可忽略）</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">        ...</div><div class="line">        msg.recycleUnchecked();<span class="comment">//处理完毕，进行回收</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Looper总结：</strong>不断从消息队列中取出消息，再分发给对应的Handler，如果消息为空，则跳出死循环，进入睡眠以让出CPU资源。</p>
<p><strong>拓展：</strong>具体事件处理过程中，程序会post新的事件进入队列，其他进程也可能投递新的事件到这个队列中，APK应用程序本质上就是不停地执行“处理队列事件”的工作，直至它退出。</p>
<h3 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal是线程内部的数据存储类，各个线程相互隔离、相互独立。<br><strong>主要作用：</strong></p>
<ol>
<li>实现Looper在线程中的存取，使得线程与Looper能够一一对应</li>
<li>实现负责逻辑下对象的传递，例如：让监听器作为线程内的全局对象，通过ThreadLocal，线程内部只要通过get即可获取到，简单又强势（当然也可以有其他方法解决：1、以函数参数方式传递；2、以监听器作为静态变量供线程访问；两种方法都有其局限性，综合来看，采用ThreadLocal是最好解决方法）</li>
</ol>
<p><strong>源码分析：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为ThreadLocal设置数据</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">	<span class="comment">//得到当前Thread</span></div><div class="line">    Thread currentThread = Thread.currentThread();</div><div class="line">    <span class="comment">//得到当前Thead中的数据，如果为空则先初始化</span></div><div class="line">	Values values = values(currentThread);</div><div class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</div><div class="line">        values = initializeValues(currentThread);</div><div class="line">    &#125;</div><div class="line">    values.put(<span class="keyword">this</span>, value);</div><div class="line">&#125;</div><div class="line"><span class="comment">//具体存储过程，可不必深究算法</span></div><div class="line"><span class="comment">//简单来说：ThreadLocal中有一个table数组，具体的值存储在reference字段所标识的下一个位置</span></div><div class="line"><span class="comment">//例如：ThreadLocal的reference对象在table中索引为index，那么其值就存在数组的index+1的位置</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line">	...</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class="line">        Object k = table[index];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == key.reference) &#123;</div><div class="line">            <span class="comment">// Replace existing entry.</span></div><div class="line">            table[index + <span class="number">1</span>] = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// Fill in null slot.</span></div><div class="line">            table[index] = key.reference;</div><div class="line">            table[index + <span class="number">1</span>] = value;</div><div class="line">            size++;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Go back and replace first tombstone.</span></div><div class="line">        table[firstTombstone] = key.reference;</div><div class="line">        table[firstTombstone + <span class="number">1</span>] = value;</div><div class="line">        tombstones--;</div><div class="line">        size++;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Remember first tombstone.</span></div><div class="line">        <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span> &amp;&amp; k == TOMBSTONE) &#123;</div><div class="line">           firstTombstone = index;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//取出ThreadLocal值，如果值为空则返回初始值（null）</span></div><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Optimized for the fast path.</span></div><div class="line">        Thread currentThread = Thread.currentThread();</div><div class="line">        Values values = values(currentThread);</div><div class="line">        <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</div><div class="line">            Object[] table = values.table;</div><div class="line">            <span class="keyword">int</span> index = hash &amp; values.mask;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</div><div class="line">                <span class="keyword">return</span> (T) table[index + <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            values = initializeValues(currentThread);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="学习资源推荐"><a href="#学习资源推荐" class="headerlink" title="学习资源推荐"></a>学习资源推荐</h2><p><a href="http://www.cloudchou.com/android/post-388.html" target="_blank" rel="external">Handler Looper MessageQueue 详解</a></p>
<p><a href="http://qifuguang.me/2015/09/02/[Java%E5%B9%B6%E5%8F%91%E5%8C%85%E5%AD%A6%E4%B9%A0%E4%B8%83]%E8%A7%A3%E5%AF%86ThreadLocal/" target="_blank" rel="external">Java并发包学习 - 解密ThreadLocal</a></p>
<p><a href="http://www.cnblogs.com/angeldevil/p/3340644.html" target="_blank" rel="external">Android消息处理机制(Handler、Looper、MessageQueue与Message)</a></p>
<p><a href="http://www.jianshu.com/p/8656bebc27cb" target="_blank" rel="external">Android消息机制 - 简书</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="external">Android异步消息处理机制完全解析，带你从源码的角度彻底理解 - 郭霖</a></p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="external">Android应用程序消息处理机制分析 - 老罗</a></p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6905587" target="_blank" rel="external">Android应用程序线程消息循环模型分析 - 老罗</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Android进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Intent 机制 - Runtime Binding]]></title>
      <url>http://yoursite.com/2016/12/06/Android%20Intent%20%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Intent 相信大家都对它不陌生，startActiviy、startService、bindService、sendBroadcast…等常用方法都需要Intent来协助完成，那么，问题来了：“Intent 是什么？其作用是什么？其中有着怎样的机制呢？”<a id="more"></a></p>
<h2 id="Intent-概述"><a href="#Intent-概述" class="headerlink" title="Intent 概述"></a>Intent 概述</h2><p>Intent是一种<strong>运行时绑定（run-time binding）机制</strong>，它是一种基于<strong>某种想要被表露的意图</strong>的被动式数据结构，它能在程序运行过程中<strong>连接两个不同的组件</strong>。通过Intent，你的程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来完成请求。</p>
<p>四大基本组件中，Activity、Service、BroadcastReceiver 都需要通过Intent机制来激活，<strong>不同的组件需要不同的Intent传递方式</strong>。</p>
<p>Intent一旦发出，Android都会准确找到<strong>相匹配</strong>的一个或多个Activity，Service或者BroadcastReceiver作响应。所以，不同类型的 Intent 消息<strong>不会出现重叠</strong>，即Broadcast的Intent消息只会发送给BroadcastReceiver，而决不会发送给Activity或者Service。由startActivity()传递的消息也只会发给Activity，由startService()传递的Intent只会发送给Service。</p>
<h2 id="Intent-结构"><a href="#Intent-结构" class="headerlink" title="Intent 结构"></a>Intent 结构</h2><ul>
<li>action – <strong>想要实施</strong>的动作，例: ACTION_VIEW, ACTION_EDIT, ACTION_MAIN, etc.</li>
<li>data – <strong>具体的数据</strong>，一般由<strong>以Uri表示</strong>，例：通讯录中的某条记录，会以Uri来表示</li>
<li>category – 为实施的动作添加的<strong>额外信息</strong>，即Intent组件的种类信息，一个Intent对象可以有任意个category，例：CATEGORY_LAUNCHER 意味着，它应该在启动器中作为顶级应用而存在</li>
<li>type – 显示指定Intent的<strong>数据类型</strong>（MIME类型 - 多用途互联网邮件扩展，Multipurpose Internet Mail Extensions），例：一个组件是可以显示图片数据的而不能播放声音文件。很多情况下，<strong>data类型可在URI中找到</strong>，比如content:开头的URI，表明数据由设备上的content provider提供。但是通过设置这个属性，可以强制采用显式指定的类型而不再进行推导<br>MIME类型有两种：单个记录格式、多个记录格式</li>
<li>component – 指定Intent的<strong>目标组件的类名称</strong>。通常 Android会根据Intent 中包含的其它属性的信息，比如action、data/type、category进行查找，最终找到一个与之匹配的目标组件。但是，如果 component这个属性有指定的话，将直接使用它指定的组件，而不再执行上述查找过程。指定了这个属性以后，Intent的其它所有属性都是可选的，例如：Intent it = new Intent(Activity.Main.this, Activity2.class); startActivity(it);</li>
<li>extras – 附加信息，例如：it.putExtras(bundle) - 使用Bundle来传递数据；</li>
</ul>
<h2 id="显式与隐式-Intent"><a href="#显式与隐式-Intent" class="headerlink" title="显式与隐式 Intent"></a>显式与隐式 Intent</h2><p>-<strong> 显式Intent</strong>：通过指定<strong>具体的组件类</strong>，通知应用启动对应的组件。例如：指定了component属性的、对Intent调用setComponent(ComponentName)或者setClass(Context, Class)的。<br>-<strong> 隐式Intent</strong>：<strong>没有指定</strong>具体component属性的Intent，设置了Action、Data、Category，让系统来筛选出合适的组件来进行调用（通过”Intent-filter”来筛选）；这些Intent需要包含足够的信息，这样系统才能根据这些信息，在在所有的可用组件中，确定满足此Intent的组件。</p>
<h2 id="Intent-解析机制"><a href="#Intent-解析机制" class="headerlink" title="Intent 解析机制"></a>Intent 解析机制</h2><p>对于<strong>显式Intent</strong>，目标组件很明确，故Android<strong>不需要解析</strong>，Android需要解析的是<strong>间接Intent</strong>，解析后，Intent即可映射给处理此Intent的Activity、Service或BroadcastReceiver。</p>
<p><strong>解析机制</strong>：</p>
<ol>
<li>通过查找已注册在AndroidManifest.xml的所有<intent-filter>及其中定义的intent</intent-filter></li>
<li>通过PackageManager来查找能够处理这个Intent的component，因为PackageManager能够获取设备上当前所安装的application package信息，解析过程主要是通过intent中的action、type、category三个属性来判断。<br>匹配规则：<ol>
<li>如果指定action，则目标组件的IntentFilter需要含有这个action</li>
<li>如果Intent没有提供type，系统将从data中得到数据类型，类似action的匹配规则，目标组件必须包含Intent的数据类型，否则不匹配</li>
<li>如果Intent中的数据不是content类型的Uri，而且Intent也没有明确指定type，将根据Intent中数据的scheme（如 http:或者mailto:）进行匹配，同上，Intent的scheme必须出现在目标组件的scheme列表中</li>
<li>如果Intent指定了一个或者多个category，那么目标组件的类别列表需要包含全部所指定的类别。（如：LAUNCHER_CATEGORY和ALTERNATIVE_CATEGORY）</li>
</ol>
</li>
</ol>
<h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p><a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent - Android Developers</a><br><a href="http://blog.csdn.net/t12x3456/article/details/7688154" target="_blank" rel="external">Android - Intent机制详解</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[探索 Android 系统启动 - 当我们按下电源键，Android 究竟做了些什么？]]></title>
      <url>http://yoursite.com/2016/11/26/%E6%8E%A2%E7%B4%A2Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android 系统启动流程的一次整体梳理。<a id="more"></a></p>
<h2 id="按下电源键"><a href="#按下电源键" class="headerlink" title="按下电源键"></a>按下电源键</h2><p><img src="http://odzvmv4ab.bkt.clouddn.com/Android%20%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h3 id="Step-1-启动电源及系统启动"><a href="#Step-1-启动电源及系统启动" class="headerlink" title="Step 1 启动电源及系统启动"></a>Step 1 启动电源及系统启动</h3><p>系统从 ROM 中开始启动，加载引导程序到 RAM ，然后执行</p>
<h3 id="Step-2-引导程序"><a href="#Step-2-引导程序" class="headerlink" title="Step 2 引导程序"></a>Step 2 引导程序</h3><p>引导程序是 Android 操作系统开始运行前的一个小程序，因此它需要针对特定主板与芯片，<strong>并不是 Android 操作系统的一部分</strong>。引导程序是 OEM 厂商或运行商进行<strong>加锁、限制</strong>的地方。</p>
<p>两个阶段：</p>
<ol>
<li>检测外部 RAM 以及为第二阶段加载程序</li>
<li>设置网络、内存等，搭建内核运行环境（为了达到特殊目的时，引导程序可以根据配置参数或者输入数据来设置内核</li>
</ol>
<p>Android引导程序可以在\bootable\bootloader\legacy\usbloader找到，传统的加载器包含的两个文件：</p>
<ol>
<li>init.s 初始化<strong>堆栈</strong>，清零<strong>BSS段</strong>（bss segment：通常是指用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域；BSS - Block Started by Symbol。BSS段属于静态内存分配），会调用 main.c 中的 _main()函数</li>
<li>main.c 初始化硬件，创建 linux 标签</li>
</ol>
<h3 id="Step-3-内核"><a href="#Step-3-内核" class="headerlink" title="Step 3 内核"></a>Step 3 内核</h3><p>Android 内核启动方式类似桌面 linux，主要步骤：<strong>设置缓存、被保护存储器、计划列表、加载驱动</strong>。 </p>
<p>当内核完成系统设置，接下来即将启动系统的第一个进程 – <strong> init 进程</strong></p>
<h3 id="Step-4-init-进程"><a href="#Step-4-init-进程" class="headerlink" title="Step 4 init 进程"></a>Step 4 init 进程</h3><p>作为 Android 系统的第一个进程，其PID为0，通过解析<strong> init.rc 脚本</strong>来构建出系统初始运行形态，这一阶段中，“Android” logo 会显示出来（系统中，<strong>大多数系统服务程序</strong>都是在<strong>该脚本</strong>中描述并被相继启动的）</p>
<p>init.rc 由<strong>4种类型声明</strong>组成：<strong>Actions、Commands、Services、Options</strong></p>
<ul>
<li><p><strong>Actions：</strong>响应某事件的过程。当“trigger”所描述的触发事件产生时，则依次执行各种“command”<br><strong>源码角度：</strong>系统会对 <strong>init.rc</strong> 中各<strong>“trigger”</strong>进行匹配，当发现符合条件的 Action，就将它加入<strong>“命令执行队列”</strong>尾部（除非 Action 已存在队列中），然后系统再对这些命令按顺序进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">on &lt;trigger&gt; ##触发条件</div><div class="line">   &lt;command1&gt; ##执行命令</div><div class="line">   &lt;command2&gt; ##可执行多个命令</div><div class="line">   ...</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Commands：</strong>命令将在所属事件发生时被一个个执行</p>
</li>
<li><p><strong>Services：</strong>可执行程序，它们在特定选项的约束下会被 init 程序运行或者重启（Service 可以在配置中指定<strong>是否需要退出重启</strong>，那么，当 Service 出现异常 crash 时，可有机会复原）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service &lt;name&gt;&lt;pathname&gt; [&lt;argument&gt;]* </div><div class="line">   &lt;option&gt;</div><div class="line">   &lt;option&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>Options:</strong>对 service 的约束选项</p>
</li>
</ul>
<h3 id="Step-5、6-ServiceManager、Zygote、SystemServer"><a href="#Step-5、6-ServiceManager、Zygote、SystemServer" class="headerlink" title="Step 5、6 ServiceManager、Zygote、SystemServer"></a>Step 5、6 ServiceManager、Zygote、SystemServer</h3><p><strong>科普：</strong>Daemons - 守护进程</p>
<p>init进程通过解析 init.rc 来陆续启动其他关键的系统服务进程，其中最重要的是<strong>ServiceManager、Zygote 和 SystemServer </strong>三者，下面我们逐一解析：</p>
<h4 id="ServiceManager-–-Binder-机制支撑者"><a href="#ServiceManager-–-Binder-机制支撑者" class="headerlink" title="ServiceManager – Binder 机制支撑者"></a>ServiceManager – Binder 机制支撑者</h4><p><strong>概述：</strong>ServiceManager 是 <strong>Binder 机制</strong>中的<strong>支撑者</strong>，负责某<strong> Binder 服务注册信息</strong>到底层 <strong>Binder 驱动分配的值</strong>解析。</p>
<p>ServiceManager 由 init 进程解析 rc 脚本时启动，属于<strong> core 类</strong>，其他同类进程包括：uenetd、console、adbd等。根据 core 组的特性，这些进程会<strong>同时启动或停止</strong>。另外，ServiceManager 配置含有 <strong>critical 属性</strong>，这意味着它是<strong>系统关键进程</strong>（如果进程不幸在4分钟内异常退出超过4次，设备将重启并进入还原模式）。当 ServiceManager 每次重启时，其他关键进程：zygote、media、surfaceflinger 等也会被 restart。</p>
<h4 id="Zygote-–-“孕育”新线程与进程"><a href="#Zygote-–-“孕育”新线程与进程" class="headerlink" title="Zygote – “孕育”新线程与进程"></a>Zygote – “孕育”新线程与进程</h4><p>Android 中大多数应用进程与系统进程都是通过 Zygote 来生成的。Zygote 同样由 init 解析 rc 脚本时启动，属于<strong> main 类</strong>，同属 main 类的系统进程有：netd、debuggerd、rild等。Zygote并不是处于独立的程序中的，它所在程序名为<strong>“app_process”</strong>，观察 app_process 主函数实现知道，如果 init.rc 中指定了 –zygote选项，app_process 接下来将启动<strong>“ZygoteInit”</strong>，并传入<strong>“start-system-server”</strong>,这样，ZygoteInit 就会运行在虚拟机上（Dalvik VM）上了。</p>
<p>ZygoteInit 函数有两项重要工作：</p>
<ol>
<li>预装载各种系统类</li>
<li>搭建 SystemServer 环境，并启动 SystemServer（大部分的 Android 系统服务都在其中，由 Java 编写）</li>
</ol>
<p>ZygoteInit 流程总结（<a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="external">摘自：Gityuan – Android 系统启动-Zygote 篇</a>）</p>
<ol>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；</li>
<li>registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高ap启动效率；</li>
<li>zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。</li>
<li>zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。</li>
</ol>
<p>ZygoteInit 结束后，开机动画就出来了（注意：前面说道的并不是开机动画，而是开机前 “Android” Logo 出现的那个画面）</p>
<h4 id="SystemServer-–-大部分-Android-系统服务所在地"><a href="#SystemServer-–-大部分-Android-系统服务所在地" class="headerlink" title="SystemServer – 大部分 Android 系统服务所在地"></a>SystemServer – 大部分 Android 系统服务所在地</h4><p>SystemServer 是 Android 进入 Launcher 前的最后准备，它提供了众多的由“Java”语言编写的<strong>系统服务</strong>。</p>
<p>如果 init.rc 中为 zygote 指定启动参数 –start-system-server，那么 ZygotyeInit 就会调用 startSystemServer 来进入 SystemServer。</p>
<p><strong>startSystemServer函数解析：</strong></p>
<ol>
<li>首先 ZygoteInit 通过 <strong>Zygote.forkSystemServer</strong> 来生成一个新的线程（fork），用于承载各种<strong>系统服务</strong>。（源码角度：Zygote 内部由 Native 函数 <strong>Dalvik_dalvik_system_Zygote_forkSystemServer</strong> 来进一步实现，最终调用底层接口的<strong> fork 接口</strong>来实际产生进程）</li>
<li>根据fork特性，子进程与父进程将获得<strong>相同的代码环境</strong>。<strong>pid为0为子进程</strong>，否则为父进程；如果是<strong>前者</strong>，则进一步调用<strong> handleSystemServerProcess(parseArgs) </strong>函数来完成最核心的工作 – <strong>“启动各系统服务”</strong>（源码角度：handleSystemServerProcess 方法将 startSystemServer 中的 <strong>parsedArgs.remainingArgs</strong> 参数传给 <strong>RuntimeInit.zygoteInit</strong>，后者又调用<strong> nativeZygoteInit 函数</strong>）</li>
<li>nativeZygoteInit 调用后，接着，三个重要的 static 函数就要被执行了：<strong>init1 - 完成本地Service(SurfaceFlinger、AudioFlinger等)启动，完成后调用 init2</strong>、<strong>init2 - 新建一个新的带 Looper 的线程 ServerThread来启动 Java层各 Service</strong></li>
</ol>
<h3 id="后续的启动"><a href="#后续的启动" class="headerlink" title="后续的启动"></a>后续的启动</h3><p>上面对 Android 系统启动做了一个简述，意在给大家展现一个整体流程，其中每个环节涉及的知识点只是浅浅掠过，笔者也尚在学习与探索中，希望在后续再作详细分析。</p>
<h2 id="资源推荐"><a href="#资源推荐" class="headerlink" title="资源推荐"></a>资源推荐</h2><ul>
<li><a href="http://gityuan.com/android/" target="_blank" rel="external">Gityuan - Android 开篇</a></li>
<li><a href="http://blog.csdn.net/luoshengyang?viewmode=contents" target="_blank" rel="external">老罗的Android之旅</a></li>
<li>《深入理解 Android 内核设计思想》 由浅入深，落实到源码层面上进行探索，知识很有深度</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java进阶 - JVM 内存管理机制探秘]]></title>
      <url>http://yoursite.com/2016/11/25/Java%20%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h2><ul>
<li>JVM 运行时数据区概述</li>
<li>JVM 对象分配、布局与访问过程</li>
<li>GC机制与内存分配策略</li>
<li>主要以 HotSpot JVM 为例进行说明<a id="more"></a></li>
</ul>
<h2 id="JVM-运行时数据区概述"><a href="#JVM-运行时数据区概述" class="headerlink" title="JVM 运行时数据区概述"></a>JVM 运行时数据区概述</h2><p><img src="http://odzvmv4ab.bkt.clouddn.com/HotSpot%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="HotSpot 运行时数据区"></p>
<ul>
<li><strong>程序计数器（线程私有）</strong>：当前线程所执行执行的<strong>字节码行号指示器</strong>。<br>JVM概念模型中，<strong>字节码解析器</strong>会通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程回复等基础功能都需要该计数器完成。<br>由于<strong>JVM多线程</strong>通过<strong>线程轮切（并发）</strong>实现，因此各线程之间计数器互相独立。</li>
<li><strong>Java虚拟机栈（线程私有）</strong>：生命周期与线程相同，描述Java方法执行的内存模型 – <em>每个方法执行时候都会创建一个<strong>栈帧（存有局部变量表、操作数、动态连接、方法出口等信息）</strong>，每个方法调用到执行完毕，对应着一个栈帧在虚拟机中入栈到出栈过程。</em><br><strong>注意：</strong>局部变量表中放的是<strong>基本数据类型以及指向对象的句柄或地址</strong>；<br>如果线程请求栈深度<strong>超过JVM允许范围</strong>，则会抛出 StackOverflowError 异常；<br>如果在动态扩展虚拟机栈时候（现在大多数JVM都可以动态扩展），<strong>内存不足</strong>，则是OOM异常；</li>
<li><strong>本地方法栈（线程私有）</strong>：与虚拟机栈相似，区别：<strong>虚拟机栈</strong>为虚拟机执行<strong>Java方法（字节码）</strong>服务；<strong>本地方法栈</strong>则为虚拟机使用到的<strong>Native方法</strong>服务。</li>
<li><strong>Java堆（线程共享）</strong>：所有<strong>对象实例以及数组</strong>都要在堆上分布（注意：随技术发展，使得<strong>不再“绝对”</strong>）；Java堆是<strong>GC管理机制的主要区域</strong>；<br>Java堆可以处于物理上不连续的内存空间，只要<strong>逻辑上连续</strong>即可；<br>无法扩展时候，会抛出<strong>OOM异常</strong>；<br><strong>堆大小</strong> = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。<br>新生代：Young Generation，主要用来存放新生的对象。<br>老年代：Old Generation或者称作Tenured Generation，主要存放应用程序声明周期长的内存对象。<br><img src="http://odzvmv4ab.bkt.clouddn.com/%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg" alt=""></li>
<li><strong>方法区（线程共享）</strong>：存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>，另外还存有一项<strong>常量池</strong>信息，存放于<strong>运行时常量池</strong>。<br>注意：<strong>运行时常量池</strong>是方法区的一部分 – <em>用于存放编译期生成的<strong>各种字面量和符号引用</strong></em></li>
<li><strong>直接内存（拓展，不属于虚拟机运行时数据区，但被频繁使用，有可能导致OOM）</strong>：JDK 1.4 中加入<strong> NIO 类（New I/O）</strong>（引入一种基于<strong>通道与缓冲区</strong>的I/O方式，可以使用<strong> Native 函数</strong>直接分配<strong>堆外内存</strong>，然后通过一个存储在<strong> Java 堆</strong>中的 <strong>DirectByteBuffer 对象</strong>作为这块内存的<strong>引用</strong>进行操作，避免了 <strong>Java 堆和 Native 堆中来回复制数据</strong>，故显著提高性能），本机直接内存不会受到 Java 堆大小的限制（当然还是受本机内存限制）</li>
</ul>
<h2 id="JVM-虚拟机对象分配、布局与访问过程"><a href="#JVM-虚拟机对象分配、布局与访问过程" class="headerlink" title="JVM 虚拟机对象分配、布局与访问过程"></a>JVM 虚拟机对象分配、布局与访问过程</h2><h3 id="对象创建-new-指令过程"><a href="#对象创建-new-指令过程" class="headerlink" title="对象创建 - new 指令过程"></a>对象创建 - new 指令过程</h3><ol>
<li><strong>类加载检查：</strong>检查<strong>指令中的参数</strong>能否在<strong>常量池</strong>中定位到一个类的符号<strong>引用</strong>，并且检查该<strong>引用的类</strong>是否<strong>已经被加载、解析与初始化过</strong>，若没有，则必须执行相应的类加载过程。</li>
<li><strong>分配内存：</strong>对象<strong>所需内存</strong>大小在类加载后就<strong>完全确定</strong>，分配空间等同于将一块确定大小的内存从<strong> Java 堆</strong>中划分出来。（指针碰撞/空闲列表 - 取决于<strong>内存是否规整</strong>，内存是否规整又取决于采用的GC机制是否有压缩整理功能）<br><strong>科普 - 指针碰撞：</strong>仅把指针向空闲空间方向挪动一段与对象大小相等的距离（<strong>通常用于Java 堆中内存规整的情况下</strong>）。<br><strong>科普 - 空闲列表：</strong>一个记录着哪些内存块可用的列表，分配时，从列表中找一块足够大的内存块划分给对象，并更新表记录（<strong>通常用于Java 堆中内存不规整的情况下</strong>）</li>
<li><strong>CAS + 失败重试方式保证更新操作的原子性</strong>：对象创建在虚拟机中非常频繁的情况下，并发情况下也并不是<strong>线程安全</strong>的即时是简单的修改指针操作。</li>
<li><strong>初始化数值：</strong>内存分配完成后，虚拟机需要将分配到的内存空间进行初始化零值，从而保证对象的实例字段不用赋值也能直接使用。</li>
<li><strong>设置对象：</strong>根据虚拟机当前的<strong>运行状态</strong>不同，是否启用<strong>偏向锁</strong>等，<strong>对象头</strong>会有<strong>不同</strong>的设置方式。</li>
<li><strong>执行 init 方法:</strong>将对象按照程序员意愿进行初始化（虚拟机角度已经完成对象创建，但对于程序员则是刚刚开始）</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>可分为三块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</p>
<ol>
<li><strong>对象头（包括两部分信息）</strong><br><strong>Part 1:</strong>存储“Mark Word” - 对象自身运行时数据（HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）；<br><strong>Part 2:</strong>类型指针，对象指向它的类元数据的指针，虚拟机会通过这个指针来确定该对象是<strong>哪个类的实例</strong>，但并<strong>不是所有虚拟机</strong>实现都必须在对象数据上保留类型指针（即：<strong>查找元数据不一定要经过对象本身</strong>）</li>
<li><strong>实例数据：</strong>对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容（父类继承的、子类中定义的都要记录）。<br>这部分的存储顺序会受到<strong>虚拟机分配策略参数（FieldAllocationStyle）</strong>和字段在<strong> Java 源码中定义顺序</strong>的影响。</li>
<li><strong>对齐填充：</strong>并不必然存在，没有特别的含有，仅仅起占位符作用（HotSpot 虚拟机要求对象起始地址必须是8字节的整数倍 – 对象大小必须是8字节的整数倍，对象头部分正好的8的整数倍，而实例数据部分没有对齐，就通过对齐填充来对齐）</li>
</ol>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>主流的访问方式：<strong>句柄、直接指针</strong></p>
<ol>
<li><strong>句柄：</strong>java 堆中将划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了对象<strong>实例数据</strong>和类型数据各自的<strong>具体地址信息</strong>。<br><strong>优势：</strong>reference 中存储的是稳定的句柄地址，在对象被移动时（GC机制会移动对象），只会改变句柄中的实例数据指针，reference 本身不需要修改。（但需要指针定位两次）<br><img src="http://odzvmv4ab.bkt.clouddn.com/%E5%8F%A5%E6%9F%84%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt=""></li>
<li><strong>指针访问方式：</strong>reference变量中直接存储的就是对象的地址，而java堆对象一部分存储了对象实例数据，另外一部分存储了对象类型数据。<br><strong>优势：</strong>速度快，节省一次指针定位的时间开销，由于对象访问频繁，积小成多后，节省的开销还是很客观的（HotSpot使用该种方法）<br><img src="http://odzvmv4ab.bkt.clouddn.com/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.jpg" alt=""></li>
</ol>
<h2 id="GC机制与内存分配策略"><a href="#GC机制与内存分配策略" class="headerlink" title="GC机制与内存分配策略"></a>GC机制与内存分配策略</h2><p><strong>程序计数器、虚拟机栈、本地方法栈</strong>是线程私有的，因此会随线程生命周期而存在，内存的分配与回收具有确定性，因此不需要过多去考虑回收。<br><strong>Java 栈、方法区</strong>是所有线程共享的，只有在程序运行时，才知道会创建什么对象，因此创建与回收都是动态的。<strong>GC机制所关注的是这部分内存。</strong></p>
<h3 id="引用计算法"><a href="#引用计算法" class="headerlink" title="引用计算法"></a>引用计算法</h3><p><strong>主流的 Java 虚拟机并没有采用引用计算法！</strong>原因：很难解决对象之间相互<strong>循环引用</strong>的问题。<br><strong>概述：</strong>给对象添加一个引用计数器，产生引用时，计数器+1；引用失效时，计数器-1；任何时刻引用为0时，认为对象不可能被引用。</p>
<p>循环引用问题 – 为何不采用？<br><strong>例子：</strong>objA.instance = objB; objB.instance = objA; 除此以外，再没有其他引用，但引用<strong>计算法计数器并不为0</strong>，因为他们相互引用对方，因此采用<strong>引用计算法</strong>会导致GC收集器无法回收该类型的对象。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><strong>基本思想：</strong>通过一系列称为<strong>“GC Roots”</strong>的对象作为起点，开始向下搜寻，搜寻走过的路径称<strong>“引用链”</strong>，当一个对象到 GC Roots 没有任何引用链相连（即<strong>不可达</strong>），则认为可回收对象。<br><strong>GC Roots 对象的选取：</strong>1.<strong>虚拟机栈</strong>（栈帧中的本地变量表）中引用的对象 2.方法区中<strong>类静态属性引用</strong>的对象 3.方法区中<strong>常量引用</strong>的对象 4.本地方法栈中 JNI（即 Native 方法） 引用对象。</p>
<h3 id="聚焦引用"><a href="#聚焦引用" class="headerlink" title="聚焦引用"></a>聚焦引用</h3><p>上述两种方法，判断对象是否“存活”的关键都在于<strong>引用</strong>。<br>JDK 1.2 之后，引用分为（<strong>强 -&gt; 弱 排序</strong>）：<br><strong>强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）</strong></p>
<ol>
<li>强引用：<strong>普遍存在。</strong>GC机制永远<strong>不会回收</strong>被强引用的对象。例：“Object obj = new Object();” </li>
<li>软引用：还有用，但<strong>非必须</strong>。系统<strong>即将OOM时</strong>，就会把这些对象列入<strong>回收</strong>范围。使用 <strong>SoftReference 类</strong>来实现。</li>
<li>弱引用：非必须，强度比软引用更弱。<strong>无论内存是否足够，只能生存到下一次GC之前。</strong>使用<strong>WeakReference 类</strong>来实现。</li>
<li>虚引用：<strong>不影响被引用对象的生存时间</strong>，生存角度上，相当于没有加引用，只是为了能在该对象<strong>被GC回收时候收到通知</strong>。使用<strong>PhantomReference 类</strong>来实现。</li>
</ol>
<h3 id="判定死亡与自我拯救"><a href="#判定死亡与自我拯救" class="headerlink" title="判定死亡与自我拯救"></a>判定死亡与自我拯救</h3><p>可达性分析算法中，至少需要经历<strong>两次标记</strong>过程，才会真正宣告一个对象的死亡。（并不是一次不可达就直接进行GC回收）<br><strong>过程</strong></p>
<ol>
<li>当对象第一次判定不可达（没有与 GC Roots 对象引用链相连），它将会被第一次<strong>标记</strong>并进行一次<strong>筛选</strong>。</li>
<li><strong>筛选：</strong>该对象是否有必要执行 finalize() 方法。<br><strong>“没有必要执行”</strong>的两种情况：<br>  1.对象<strong>没有覆盖</strong> finalize() 方法；<br>  2.finalize() 方法<strong>已经</strong>被虚拟机<strong>调用过</strong>.</li>
<li><strong>若“有必要执行 finalize()”:</strong>对象会被加入 <strong>F-Queue</strong> 中，随后由一个虚拟机自动建立的、低优先级的<strong> Finalize 线程</strong>去执行（<strong>触发</strong>对象的<strong>finalize()</strong> 方法），但虚拟机<strong>不会等到它运行结束</strong>（防止对象的 finalize() 方法执行缓慢，导致 F-Queue 其他对象过久等待）。<br><strong>finalize()</strong> 方法是对象最后一次<strong>自我拯救</strong>的机会，Finalize 线程触发对象的 finalize()方法后，GC将会对 F-Queue 中的对象进行<strong>第二次小规模标记</strong>，如果对象仍然是<strong>无关联</strong>（不可达），那么对象就真的被<strong>判定死亡了（GC回收）</strong>；而如果对象<strong>建立了关联</strong>，本次标记就会把对象<strong>移除“即将回收”的集合</strong>，逃离GC回收。<br><strong>自我拯救</strong>方法：在 finalize() 方法中重新与<strong>引用链</strong>上任意一个对象建立关联即可（并不推荐这么做，应该尽量避免，该方法是为了让C/C++程序员更好接受Java所做出的妥协，作为Java程序员，我们大可将它直接忘掉）</li>
<li><strong>注意：</strong>任意一个对象的 finalize() 方法只会被系统<strong>自动调用一次</strong>，当对象面临下一次回收时候，finalize() 方法就不会再次执行。</li>
</ol>
<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>HotSpot 虚拟机中的<strong>永生代</strong> - 即方法区:是指内存的永久保存区域，主要存放 <strong>Class、Meta</strong> 的信息,Class 在被 Load 的时候被放入 PermGen space 区域. 它和存放 Instance 的 Heap 区域不同,GC不会在主程序运行期对PermGen space进行清理，所以如果你的应用会加载很多Class的话,就很可能出现PermGen space错误。</p>
<p><strong>java虚拟机规范</strong>中确实说过可以<strong>不要求虚拟机在方法区实现垃圾收集</strong>，而且在方法去中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此。 </p>
<p>主要回收两个内容：<strong>废弃的常量和无用的类</strong></p>
<p><strong>废弃常量回收方法：</strong>类似 Java 堆中的对象回收，没有引用的时候，就进行回收。（书本上的<strong>例子：</strong>加入一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”abc”的，换句话说，就是有任何String对象应用常量池中的”abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。<strong>注意：JDK 1.7 及以后的版本已经将字符串常量池从永久代中移除</strong>）</p>
<p><strong>如何判断无用的类？ – 满足以下三个条件：</strong></p>
<ol>
<li>该类所有的实例都已经被回收，也就是java堆中<strong>不存在该类的任何实例</strong>。</li>
<li>加载该类的 <strong>ClassLoader</strong> 已经<strong>被回收</strong></li>
<li>该类对应的 java.lang.Class 对象<strong>没有在任何地方被引用</strong>，<strong>无法</strong>在任何地方通过<strong>反射访问</strong>该类的方法。</li>
</ol>
<p>虚拟机<strong>可以</strong>对满足上述三个条件的无用类进行回收，这里说的<strong>仅仅是“可以”</strong>，而并不和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了 <strong>-Xnoclassgc</strong> 参数进行控制。（如果关闭CLASS的垃圾回收功能，就是虚拟机加载的类，即便是不使用，没有实例也不会回收）</p>
<p>另外：在大量使用反射、动态代理、CGlib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都<strong>需要虚拟机具备类卸载的功能，以保证永久代不会溢出</strong>。</p>
<h2 id="书目推荐"><a href="#书目推荐" class="headerlink" title="书目推荐"></a>书目推荐</h2><ul>
<li>强势推荐 《深入理解 Java 虚拟机》，由浅入深并结合实践，十分优秀的一本书！ </li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Java进阶 </tag>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android 触控事件解析]]></title>
      <url>http://yoursite.com/2016/11/19/Mastering%20The%20Android%20Touch%20System/</url>
      <content type="html"><![CDATA[<h2 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h2><ul>
<li><strong>MotionEvent</strong> 概述 </li>
<li>Android <strong>如何传递</strong>触控事件？</li>
<li>Android <strong>如何处理</strong>触控事件？</li>
<li>具代表性的<strong>例子</strong>说明</li>
<li><strong>拓展 - </strong>注意事项、多点触控、Batching、Hover Events、Touch Delegate</li>
<li><strong>干货</strong>推荐 <a id="more"></a></li>
</ul>
<h2 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h2><p>Android 会把每一个触控事件包装成 MotionEvent，其中携带了许多自身事件带来的或额外的信息，包括 Touch 位置、时间、历史记录以及触控点数（屏幕上的手指数）等。</p>
<p><strong>其中，事件类型包含：</strong></p>
<ul>
<li>ACTION_DOWN</li>
<li>ACTION_UP</li>
<li>ACTION_MOVE</li>
<li>ACTION_POINTER_DOWN（屏幕上已有触控点，再按下其他触控点）</li>
<li>ACTION_POINTER_UP（屏幕上当前有多个触控点，松开非最后一个点）</li>
<li>ACTION_CANCEL<br><strong><br>注意：</strong>每一个触控事件都是：ACTION_DOWN 开始，ACTION_UP 结束。</li>
</ul>
<h2 id="Android-如何传递触控事件？"><a href="#Android-如何传递触控事件？" class="headerlink" title="Android 如何传递触控事件？"></a>Android 如何传递触控事件？</h2><p>触控事件会最先发送给前台顶端的 Activity ，最先获取触控事件的，是其中的 dispatchTouchEvent() 方法。</p>
<p>事件通过上层 View 或 ViewGroup，调用各自的 dispatchTouchEvent() 方法，一直往下(子View)传递。而事件回传时，View 或者 ViewGroup 则会调用 onTouchEvent()方法。</p>
<p><strong>小坑：</strong>既然 Activity 是触控事件传递的第一站，那么如果在 Activity 中的 onTouchEvent() 进行操作，那么会不会马上就可以检测到触控事件呢？然而，这样是<strong>错误的</strong>，实际上，Activity 中的 onTouchEvent() 方法是触控事件的终点，而如果传递过程中有 View 已经消耗了该事件，那么 Activity 中的 onTouchEvent() 方法则不会调用。</p>
<p>处理触控事件的另外一种方式 - <strong>onTouchListener</strong>：与 onTouchEvent() 很相似，可以 return true 来消费触控事件；注意： onTouchListener 优先于 onTouchEvent() 进行消费</p>
<h2 id="Android-如何处理触控事件？"><a href="#Android-如何处理触控事件？" class="headerlink" title="Android 如何处理触控事件？"></a>Android 如何处理触控事件？</h2><p>接收到触控事件后，Activity 自身 dispatchTouchEvent() 首先会传递给 RootView（大多数情况是 ViewGroup）,而 ViewGroup 会继续传递给其中的 childView，childView 又会继续传递给 childView 的 childView，如果整个过程都没有 View 消费触控事件，那么 Activity 的 onTouchEvent() 会是整个触控事件的终点</p>
<h3 id="View-dispatchTouchEvent-方法"><a href="#View-dispatchTouchEvent-方法" class="headerlink" title="View.dispatchTouchEvent() 方法"></a>View.dispatchTouchEvent() 方法</h3><p>检查是否含有 onTouchListener ,如果有，则优先给 listener 处理；如果没有 onTouchListener 或者 listener 中没有对触控时间进行消费（没有 return true）,那么时间就会返回视图树的上层，给父控件处理。</p>
<h3 id="ViewGroup-dispatchTouchEvent-方法"><a href="#ViewGroup-dispatchTouchEvent-方法" class="headerlink" title="ViewGroup.dispatchTouchEvent() 方法"></a>ViewGroup.dispatchTouchEvent() 方法</h3><p>对比 View ，更加复杂。</p>
<ul>
<li>对 childView 进行管理，处理事件时，需要对自身 childView 进行遍历，来找出可能对触控事件感兴趣的 view。<strong>实际上，</strong>GroupView 会根据触控位置来判断，如果触控位置在 childView 内部，说明触控事件与其相关；如果相关的 View 不止一个（即：有重叠），那么 ViewGroup 会逆序（加入 ViewGroup 的顺序的逆序，也就是从表层 View 到底层 View ）遍历 childView，其中的处理过程与普通的时间传递相同<br>。</li>
<li>另外，ViewGroup 还会对触控事件进行中断或者窃取子 View 的触控事件，可以通过以下方法来实现： <strong>onInterceptTouchEvent(boolean flag) 方法</strong>来实现，该方法不断监测流入此 ViewGroup 的触控事件，监测目的在于：<strong>在某时间，结合对应手势，使 ViewGroup 停止事件分发（转而直接交给自己来处理事件）</strong>，例子： ScrollView（内部有一个 Button），当手指放到 Button 上，然后进行上下滑动，会发现手势交给了 ScrollView，并且开始滚动（ScrollView 优先于 Button 的响应）</li>
<li>然而，ViewGroup 又有另外一个方法来打断 onInterceptTouchEvent() 方法的逻辑（childView 需要知道 parentView 是暂时屏蔽或是永久屏蔽触控事件），该方法便是<strong>“requestDisallowTouchIntercept()”</strong>,它可以中断 onInterceptTouchEvent() 方法，例子：ScrollView 内部有 childView 想要处理拖拽事件而不是交给ScrollView 处理；<strong>注意：</strong>需要针对特定手势来设置标识，而且对当前触控事件有效（ACTION_UP 意味着当前触控事件结束，下一次 ACTION_DOWN 会重置该标识，如果仍需要拦截，需要再次调用requestDisallowTouchIntercept()方法，也就是说，需要针对某个手势，每次都调用该方法去设置中断标识）。</li>
</ul>
<h2 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h2><p>一个 Activity 中有一个 FrameLayout(即 ViewGroup),其中又有一个 View，他们都不可点击（不会对触控事件进行任何处理，从而演示整个触控事件的传递过程）<br><img src="http://odzvmv4ab.bkt.clouddn.com/Ignorant%20View%20Example.jpg" alt=""></p>
<ul>
<li>ACTION_DOWN：从上往下进行触控事件分发，再从下往上判断触控事件处理方式（是否拦截）</li>
<li>ACTION_MOVE/ACTION_UP：框架会认为，既然之前已经知道没有 View 对 ACTION_DOWN 感兴趣了，那么 ACTION_MOVE、ACTION_UP 也就不需要再分发了（直接在 Actvity 转一圈）。</li>
</ul>
<p>如果，将中间的 View 换成对触控事件有响应的 Button<br><img src="http://odzvmv4ab.bkt.clouddn.com/Interested%20View%20Example.jpg" alt=""></p>
<ul>
<li>ACTION_DOWN：依旧是同样的触控事件分发过程，但由于 Button 拦截了触控事件，即 Button 消费了本次触控事件，因此，本次触控事件在 Button 处结束</li>
<li>ACTION_MOVE/ACTION_UP：所有的移动触控事件，从 MOVE 到UP，或者再放几根手指在上面（Button 上面），触控事件会走同样的流程，最终在 Button 上结束（当然，父控件的 onInterceptTouchEvent() 还是能监控事件的 ）</li>
<li>照应上面的<strong>小坑</strong>：Activity 中的 onTouchEvent()是分发的终点，如果中途被消费，则就不会调用了</li>
</ul>
<p>如果，再把 FrameLayout 换成可以滚动的 ScrollView<br><img src="http://odzvmv4ab.bkt.clouddn.com/Intercept%20Example.jpg" alt=""><br>ACTION_DOWN：触控事件同样到达 Button 处被消费<br>ACTION_MOVW/ACTION_UP：按住 Button，然后手指开始在屏幕上滑动，然后松开手指;ScrollView 检测到滑动事件，事件分发线路发生了改变（本身 ViewGroup 的 dispatchTouchEvent() 方法会把事件分发给内部的 childView，但 ScrollView 的 onInterceptTouchEvent() 方法返回 true，则 ViewGroup 就直接把事件发送给自身的 onTouchEvent() 而不是继续递归调用 childView 的dispatchTouchEvent() 方法 ），ScrollView （即ViewGroup）会直接截获触控事件，当然，触控位置也会随之从 Button 内部的坐标转换为自身内部的坐标。</p>
<p>注意：其实 Button 也会收到 ACTION_CANCEL 这一触控事件。因为当 ACTION_MOVE 触控手势被检测到时候，Button 上的触控事件会被窃取，系统需要让 Button 知道，它已经不能再接收任何触控事件了，于是给 Button 发送 ACTION_CANCEL，所以，在一个 ScrollView 中的 Button，点击它，再进行上下滑动，再松开，Button 并没有触发点击事件。 通常 ACTION_CANCEL、ACTION_UP 通常用于结束当前手势触控事件。</p>
<h2 id="ViewConfiguration-类"><a href="#ViewConfiguration-类" class="headerlink" title="ViewConfiguration 类"></a>ViewConfiguration 类</h2><p>该类携带许多供框架使用的常量，开发者需要在程序中使用这些常量，来使得你的事件处理与系统的处理一致。其中大多数都是与触控相关的，当然也会有与画图或者其他方面相关的常量存在，下面，挑几个相对重要的常量进行介绍。</p>
<h3 id="getScaledTouchSlop-方法"><a href="#getScaledTouchSlop-方法" class="headerlink" title="getScaledTouchSlop() 方法"></a>getScaledTouchSlop() 方法</h3><p>概述：touchSlop 是一个定义的值，此值用于跟触控事件作比较，从而决定能否从轻触转换为拖拽。</p>
<p>如果你将手指放置于屏幕，尽可能的不移动，但被触控到的 View 还是会收到很多 ACTION_MOVE 事件，因为手指很容易颤动，细微的振动，系统为了探知手指位置，会产生大量的 ACTION_MOVE 事件，尽管用户根本没有移动手指。此时，touchSlop 开始发挥作用了，系统会将手指移动距离与 touchSlop 常量作对比，从而判断该动作为轻触还是移动。</p>
<h3 id="fling"><a href="#fling" class="headerlink" title="fling"></a>fling</h3><p>用于判断当手指离开屏幕时候，屏幕应该滚动还是停止。通常我们都会有一种体验，快速滑动 ScrollView ，往往控件会再继续滚动一会。那么系统是如何进行判断的呢？</p>
<p>当手指以移动状态离开屏幕（没有停下），并且速度比系统定义的 fling 值大，系统框架就会认为此手势是 fling，可滚动控件就会根据手指移动速度进行相应的滚动，当然，系统也会有一个最大 fling 速度，当用户手指速度超过该速度时，控件的滚动速度达到最大，而不会再加快。</p>
<h3 id="scaledPagingTouchSlop"><a href="#scaledPagingTouchSlop" class="headerlink" title="scaledPagingTouchSlop"></a>scaledPagingTouchSlop</h3><p>该常量常用于 ViewPager，与 touchSlop(ScaleTouchSlop) 区分开，这里的 touchSlop 指的是横向翻页的 touchSlop ，不同于一般的滑动 touchSlop，当然，这并不是说明所有横向的 slop 都使用这一常量。</p>
<p><strong>问题来了，为什么要设置两种 Slop </strong>：主要是因为考虑到，当 ScrollView 嵌套与 ViewPager 中，该如何使得两者较好的工作，因此，需要 x、y轴上分别有两种不同的 Slop 检查，从而判断出用户想上下滚动还是侧滑</p>
<h3 id="系统常量的好处"><a href="#系统常量的好处" class="headerlink" title="系统常量的好处"></a>系统常量的好处</h3><p>这些常量与屏幕分辨率无关，类似于 dp ，它们根据不同的屏幕密度来进行缩放，大大方便了开发者写出与系统行为相互适应的 App </p>
<h2 id="处理触控事件的注意事项"><a href="#处理触控事件的注意事项" class="headerlink" title="处理触控事件的注意事项"></a>处理触控事件的注意事项</h2><p>例子：屏幕上有两个 Button A、B，现在想要做到一种效果，用户点击 A ,但在 B 做出点击响应，而用户点击 B 时候，则是 A 做出响应，即：想 A 把触控事件传递给 B，B 把触控事件传递给 A 。</p>
<p>一般的想法：在 A 按钮触控事件处理中（dispatch 或者 onTouchEvent 方法）调用 B 按钮的 onTouchEvent 方法来处理事件。技术角度上，确实可行，但如果这么做，整个事件响应链的剩余部分会在此处被避开了。因为在 View 的 dispatch 方法中，还做了许多其他不必要的事情。</p>
<p>最佳且最适当的做法：顺应系统事件分发链来做，当事件传进来，调用另一个 View 的 dispatch 方法。</p>
<h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent()"></a>onInterceptTouchEvent()</h3><p>事件传递过程中，每个 View 都会先检查该方法的返回值，只要 ViewGroup 中的该方法返回 false ，事件才会走正常的传递链，而如果该方法返回 true，那么当前手势所有的后继触控事件都会直接传递给当前 ViewGroup 的 onTouchEvent() 事件，而本来会接收到触控事件目标 View 会收到 ACTION_CANCEL，这一过程是不可逆的，另外，值得注意的是，onInterceptTouchEvent() 作用是一次性的，需要每次针对特定方法调用该方法才能每次生效。</p>
<p>因此，ViewGroup 一旦把触控事件拦截了，那么就必须处理整个事件，而不能只处理一部分事件，然后把事件还回去。<strong>结论：除非完全处理事件，否则不要拦截事件</strong>。</p>
<h3 id="尽可能地把不需要处理的事件传递给父类"><a href="#尽可能地把不需要处理的事件传递给父类" class="headerlink" title="尽可能地把不需要处理的事件传递给父类"></a>尽可能地把不需要处理的事件传递给父类</h3><p>View 中的 onTouchEvent() 方法实际上是做了许多操作来维护 View 自身的状态的（pressed、checked…），如果拦截了所有的事件，那么 View 自身的状态维护功能就会丢失，而开发者往往摸不着头脑，因此，与其直接返回 true 或者 false ，不如直接返回一个对父类的调用。</p>
<h3 id="注意使用-Slop-常量进行检查"><a href="#注意使用-Slop-常量进行检查" class="headerlink" title="注意使用 Slop 常量进行检查"></a>注意使用 Slop 常量进行检查</h3><p>处理 ACTION_MOVE 的时候，需要使用该常量来判断用户是否真正想要移动，还是只是在轻触屏幕</p>
<h3 id="考虑如何处理-ACTION-CANCEL-事件类型"><a href="#考虑如何处理-ACTION-CANCEL-事件类型" class="headerlink" title="考虑如何处理 ACTION_CANCEL 事件类型"></a>考虑如何处理 ACTION_CANCEL 事件类型</h3><p>大多数情况下，ACTION_CANCEL、ACTION_UP 是放在一起处理的，当时也会有情况会造成两者不同时出现的情况，例如，最常见的：用户手指弹起导致的 ACTION_UP，或者 ACTION_CANCEL 是由于 View 中事件被窃取而产生的（上文提及的：ScrollView 与 Button 滚动的情况）。当 ACTION_CANCEL 与 ACTION_UP 没有同时出现的时候，就可能需要将它们分开处理了（尽管大多数情况下，放在一起处理也是没有什么问题的，主要的操作是：重置 View 的状态）</p>
<h2 id="多点触控的处理"><a href="#多点触控的处理" class="headerlink" title="多点触控的处理"></a>多点触控的处理</h2><p>首先需要明确的是，不论是单点还是多点触控，都是遵循系统触控框架的调用流程的，整个分发过程上，两者没有任何不同，唯一不同的仅仅在于系统报告的触控点数量超过了 1 。</p>
<h3 id="MotionEvent-getPointerCount"><a href="#MotionEvent-getPointerCount" class="headerlink" title="MotionEvent.getPointerCount()"></a>MotionEvent.getPointerCount()</h3><p>该方法会根据每个事件，读出当前有几个触控点正在设备跟踪记录，但设备记录的有效触控点数可能会有限，当超过设备支持的触控点数时，设备的有效追踪点数，当然就不会再增加了。</p>
<h3 id="ACTION-POINTER-DOWN-与-ACTION-POINTER-UP"><a href="#ACTION-POINTER-DOWN-与-ACTION-POINTER-UP" class="headerlink" title="ACTION_POINTER_DOWN 与 ACTION_POINTER_UP"></a>ACTION_POINTER_DOWN 与 ACTION_POINTER_UP</h3><p>当用户放了 1 根手指在屏幕上，再继续放第 2、3、4 根手指时候，那么此时触发的就是 ACTION_POINTER_DOWN，而松开手指时候，触发的是 ACTION_POINTER_UP，直到只剩下 1 根手指在屏幕上，最后 1 根手指松开时候，触发 ACTION_UP</p>
<p>系统会为屏幕上的每个触控点设置一个 index 与 id，开发者可使用其来对整个手势每个触控点做跟踪记录。</p>
<p>index 可变而 id 不可变，假设：当用户放 3 根手指在屏幕上，index 与 id 分别为0，1，2；0，1，2。而用户松开了一根手指（id 为 1 的触控点消失）后，index 与 id 可能就会变成 0，1；0，2。 index 更多的是与屏幕上当前触控点相关（还剩多少个触控点），而 id 仅仅作为触控点的标记（针对某个触控点进行相关操作）</p>
<p>注意：通常，触控点减少时，系统默认会把<strong>在减少的触控点上的后续触控事件</strong>传递到前一个 index 的触控点上。</p>
<h2 id="Batching-批量处理"><a href="#Batching-批量处理" class="headerlink" title="Batching 批量处理"></a>Batching 批量处理</h2><p>通常，设备实际产生的触控事件往往产生的比你相像的要多很多（由硬件以及内核驱动而产生），尽管用户只是在屏幕上轻轻滑动一下。因此，View 实际上并没有检测到每一个单独的事件，而是获取到批量处理后的结果（成批事件处理中的最后一个事件）</p>
<p>如果因为某种原因，你需要对系统生成的每一个事件都做检测或者想得到每一个单独事件，那可能需要用这些方法来构建（MotionEvent 类中的方法）：</p>
<ul>
<li>获取当前最新事件信息： getX()、getY()、getEventTime() </li>
<li>ACTION_MOVE 过程中获取的触控事件：getHistoricalX()、getHistoricalY()、getHistoricalEventTime()；getHistoricalSize() – 获取 batched events 数量</li>
</ul>
<h2 id="Hover-Events-悬浮事件"><a href="#Hover-Events-悬浮事件" class="headerlink" title="Hover Events 悬浮事件"></a>Hover Events 悬浮事件</h2><p>API 14（Android 4.0）之后加入：ACTION_HOVER_ENTER、ACTION_HOVER_EXIT、ACTION_HOVER_MOVE，当然，这些都是 MotionEvent 类之中的定义的。</p>
<p>部分设备，例如：SAMSUNG 的手机部分就支持悬浮操作，或者是在 Android 设备上接入鼠标，鼠标悬浮在特定的 View 上面，就会触发悬浮事件，事件分发流程与普通触控事件一致。</p>
<p><strong>而不同之处：</strong>回调函数与普通触控事件的<strong>回调函数</strong>不一样，这些事件不会在 onTouchEvent 中检测到<br>，而是在 View.onGenericMotionEvent() 方法中，或者设置 View.onGenericMotionEventListener ，虽然方法传入的参数与普通触控事件在 onTouchEvent 中传入的参数并无差异。我们可以这么认为：系统想要将悬浮事件与触控事件分开处理，所以特地分出了特殊处理的方法，而整个事件分发流程实质上是相同的。</p>
<p><strong>注意：</strong>系统默认是<strong>没有</strong>处理<strong>悬浮事件</strong>的，需要靠用户来自行定制。</p>
<h2 id="Touch-Delegate-触摸代理"><a href="#Touch-Delegate-触摸代理" class="headerlink" title="Touch Delegate 触摸代理"></a>Touch Delegate 触摸代理</h2><p><strong>设计目的：</strong>允许父视图去定义一个特定的触摸区域，而在这个触摸区域中，所接收到的所有事件会向前传递给某个 childView。</p>
<p><strong>应用例子：</strong>假如 ListView 中有一些图标太小以至于难以触摸，但又希望用户能点击时。可以使用触摸代理来定义一个区域，把此区域的所有触摸事件传递给那个很小的图标。（这种情况，其实完全可以直接把图标设置大一些，例如：Padding属性，这样更加简单快捷；触摸代理主要是针对一些无法简单扩大的 View 范围，不得不这么做的情况）</p>
<h2 id="资源推荐"><a href="#资源推荐" class="headerlink" title="资源推荐"></a>资源推荐</h2><ul>
<li><a href="&quot;http://v.youku.com/v_show/id_XODQ1MjI2MDQ0.html&quot;">视频 - Mastering the Android Touch System</a></li>
<li><a href="&quot;https://github.com/devunwired/custom-touch-examples&quot;">Github - 演示 Demo </a><br><strong>Examples include:</strong><ul>
<li>Overriding onTouchEvent()</li>
<li>Overriding onInterceptTouchEvent()</li>
<li>GestureDetector</li>
<li>ScaleGestureDetector</li>
<li>TouchDelegate</li>
</ul>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android网络编程 - TCP/IP协议实践]]></title>
      <url>http://yoursite.com/2016/11/07/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20-%20TCP%E3%80%81UDP/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>简要回顾了 TCP/IP 分层模型及 IP、TCP、UDP 等主要协议，并且在此基础上联系 Android，做出一定的代码实现。</li>
<li>推荐书目：《深入理解Android网络编程》、《计算机网络 - 自顶向下方法》、《TCP/IP详解》<a id="more"></a><h2 id="网络协议概述"><a href="#网络协议概述" class="headerlink" title="网络协议概述"></a>网络协议概述</h2></li>
<li>大多数网络都采用<strong>分层</strong>的体系结构，每一层都建立在它下层之上，同时向它的上一层提供服务。</li>
<li>网络各层中存在许多协议，接收方与发送方同层协议必须一致。</li>
<li>由于网络结点之间联系复杂，制定协议，通常把复杂成分分解成简单的成分，再将它们组合。<br>常用的复合技术 - “层级结构”：<ul>
<li>结构中每一层都规定明确的任务以及接口标准</li>
<li>将用户的应用程序作为最高层</li>
<li>除了最高层，中间的每一层都向上提供服务，同时又是下一层的用户</li>
<li>物理层座位最低层，使用最高层传来的参数，是提供服务的<strong>基础</strong></li>
</ul>
</li>
<li>ISO提出的OSI/RM模型将计算机网络体系结构通讯协议划分为七层：物理层、数据链路层、网络层、传输层、；会话层、表示层、应用层（物数网传会表应）<br>低4层完成数据传输服务、高3层面向用户：<ul>
<li>应用层 - 为应用提供访问网络服务接口</li>
<li>表示层 - 提供数据/信息表示变换，让不同编码计算机可相互理解</li>
<li>会话层 - 组织同步不同计算机的进程通信（对话），对话的建立与拆除；还提供在数据流中插入同步点机制，数据传输中断后，也不必从头开始，仅重传最近一个同步点以后的数据</li>
<li>传输层 - 源主机与目的主机的连接与数据传输（端到端的数据传输）</li>
<li>网络层 - 寻找合适的路由，使网络层数据传输单元（分组）可以正确找到目的站</li>
<li>数据链路层 - 两个相邻结点间无差错地以帧为单位的数据传送</li>
<li>物理层 - 物理介质传输，比特流传输</li>
</ul>
</li>
</ul>
<h2 id="IP、TCP-和-UDP-协议"><a href="#IP、TCP-和-UDP-协议" class="headerlink" title="IP、TCP 和 UDP 协议"></a>IP、TCP 和 UDP 协议</h2><h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><ul>
<li>即互联网协议（Internet Protocol），用于报文交换网络的一种面向数据的协议，是TCP/IP协议中网络层的主要协议。</li>
<li>作用：根据源主机和目的主机的地址传送数据。</li>
<li>IP定义了寻址方法和数据报的封装结构。（IPv4、IPv6）</li>
</ul>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><ul>
<li>TCP/IP模型中，面向连接的、可靠的、基于字节流的传输层通信协议；</li>
<li>传输层存在的意义：应用层之间需要可靠的，像管道一样的连接，但网络层不提供这样的流机制，只提供不可靠的包交换，因此需要传输层的协调。</li>
<li>TCP协议作用：<ul>
<li>TCP协议把应用层向传输层发送网间传输的、用8位字节表示的数据流分成适当长度的报文段（受数据链路层最大传输单元MTU限制）；</li>
<li>把包传给网络层，由网络层将包传送给接收端实体的传输层；TCP为了不发生丢包，给每个包一个序号，同时序号保证了传送到接收端实体的包能按序接收。然后接收实体成功收到包后回复相应的ACK确认；</li>
<li>如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就会被认为丢失，将被重传；</li>
<li>TCP协议用一个校验和（Checksum）函数来检验数据是否错误，发送与接收时候都需要计算校验和。</li>
</ul>
</li>
</ul>
<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><ul>
<li>TCP/IP模型中面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。</li>
<li>UDP不提供对IP协议的可靠机制、流控制以及错误恢复功能等，在数据传输之前不需要简历连接。</li>
<li>由于UDP较简单，因此比TCP负载消耗少。</li>
</ul>
<h2 id="Android-中的运用？"><a href="#Android-中的运用？" class="headerlink" title="Android 中的运用？"></a>Android 中的运用？</h2><p>TCP、UDP报文结构中，每段报文除了数据本身，还包含了许多其他重要信息，而且长度有限，传输时候需要拆解，到达目的地之后再组合还原，如果包有丢失或者损坏还需要重传，乱序发送的包还需要重新排序。<br>处理传输过程中的一系列逻辑，需要大量可靠的代码完成。于是人们他用过 Socket 对网络纠错、包大小、包重传等进行封装。</p>
<h3 id="Socket-基础"><a href="#Socket-基础" class="headerlink" title="Socket 基础"></a>Socket 基础</h3><ul>
<li>从字面意思来看，“Socket”通常被称为“套接字”。相信很多人都不理解“套接字”是什么意思，包括我，也是疑惑了很久。</li>
<li>Socket 作用距离：一台服务器可能会提供多种服务，每种服务对应一个 Socket，客户也持有一个 Socket，客户需要哪种服务，就需要找到对应的Socket来进行通信。</li>
<li>Socket 是应用层与TCP/IP协议族通信的中间软件抽象层，它本质是一组接口。Socket 接口将复杂的TCP/IP协议族隐藏，对用户而言，一组简单的接口就是全部，让 Socket 组织数据，以符合指定协议。</li>
<li>应用程序常通过 Socket 向网络发送/响应请求</li>
<li>Socket <strong>基本操作</strong>：1、连接远程机器；2、发送数据；3、接收数据；4、关闭连接；5、绑定端口；6、监听到达数据；7、在绑定端口上接收来自远程及其的连接</li>
<li>服务器要和客户端通信，两者需要实例化一个Socket。服务器和客户端的Socket不一样，客户端可以实现连接远程机器、发送数据、接收数据、关闭连接等，服务器还需要实现绑定端口、监听到达数据、接收来自远程机器的连接。Android 中，java.net里面提供的两个类：ServerSocket、Socket，前者用于实例化服务器 Socket，后者用于实例化客户端的 Socket。</li>
<li>Socket 的两种类型：TCP、UDP<br>TCP 与 UDP 在传输过程中的具体实现方式不同，两者都接收传输协议数据包并将其内容向前传递到应用层。<br>TCP 把消息分解成数据包，并在接收端以正确的顺序将他们重新装配起来；TCP 还处理丢包的重传请求，位于上层的应用层要处理的事情就相对较少。<br>UDP 不提供装配与处理重传请求，只是向前传递信息包，位于上层的应用必须确保消息是完整的，并且是以正确的顺序装配的。</li>
</ul>
<h3 id="使用-TCP-通信与-UDP-通信"><a href="#使用-TCP-通信与-UDP-通信" class="headerlink" title="使用 TCP 通信与 UDP 通信"></a>使用 TCP 通信与 UDP 通信</h3><ul>
<li><p>TCP:保证可靠性上，采用超时重传和捎带确认机制；流量控制上，采用滑动窗口协议（协议规定，对于窗口内，未经确认的分组需要重传）；拥塞机制上，采用慢启动算法。<br>场景应用：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。</p>
<ul>
<li><p>TCP 服务器端工作流程：</p>
<ol>
<li>SerserSocket(int port) 创建 ServerSocket，并将其绑定到指定端口</li>
<li>调用 accept()，监听连接请求，如果客户端请求连接，则接受并返回通信 Socket</li>
<li>调用 Socket 类的 getOutputStream()、getInputStream() 获取输出和输出流，开始网络数据发送与接收</li>
<li>通信结束，关闭通信套接字</li>
</ol>
</li>
<li><p>TCP 客户端工作流程：</p>
<ol>
<li>调用 Socket() 创建一个流套接字，并且连接至服务器端</li>
<li>调用 Socket 类中的 getOutputStream()、getInputStream() 方法获取输出和输入流，开始网络数据的发送与接收</li>
<li>通信结束，关闭通信套接字</li>
</ol>
</li>
</ul>
</li>
<li><p>UDP:有不提供数据报分组、组装和不能对数据包排序的缺点，无法得知其是否安全完整到达。UDP 主要用来支持那些需要在计算机之间传输数据的网络应用，对网络通讯质量要求不高，要求较快的通信速度时使用。<br>主要作用：将网络数据流量压缩成数据报的形式。（典型数据报：一个二进制的传输单位）</p>
<ul>
<li><p>UDP 服务器端工作流程：</p>
<ol>
<li>调用 DatagramSocket(int port) 创建一个数据报套接字，并绑定到指定端口</li>
<li>调用 DatagramPacket(byte[]buf,int length)，建立字节数组以接收 UDP 包</li>
<li>调用 DatagramSocket 类的receiver(),接受 UDP 包</li>
<li>通信结束，关闭数据报套接字</li>
</ol>
</li>
<li><p>UDP 客户端工作流程：</p>
<ol>
<li>调用 DatagramSocket() 创建一个数据报套接字</li>
<li>调用 DatagramPacket(byte[]buf,int offset,int length,InetAddress address,int  port)，建立要发送的 UDP 包</li>
<li>调用 DatagramSocket 类的 send() 发送 UDP 包</li>
<li>通信结束，关闭数据报套接字</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="简单的通信-Demo"><a href="#简单的通信-Demo" class="headerlink" title="简单的通信 Demo"></a>简单的通信 Demo</h3><p>实现了服务器端与客户端的交互（客户端发送消息至服务器端）；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">ChatServer.java</div><div class="line">public class ChatServer extends Thread &#123;</div><div class="line">    /**</div><div class="line">     * 服务器Socket对象</div><div class="line">     */</div><div class="line">    private ServerSocket server = null;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 端口</div><div class="line">     */</div><div class="line">    public static final int PORT = 5000;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 读写Buffer</div><div class="line">     */</div><div class="line">    private BufferedReader reader;</div><div class="line">    private BufferedWriter writer;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 主线程Handler</div><div class="line">     */</div><div class="line">    private final Handler handler;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 标识</div><div class="line">     */</div><div class="line">    public static final int SERVER_TAG = 12345;</div><div class="line">    public static final String MSG_KEY = &quot;server&quot;;</div><div class="line"></div><div class="line">    public ChatServer(Handler handler) throws IOException &#123;</div><div class="line">        this.handler = handler;</div><div class="line">        createSocket();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 创建ServerSocket</div><div class="line">     */</div><div class="line">    private void createSocket() throws IOException &#123;</div><div class="line">        server = new ServerSocket(PORT, 100);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        Socket client;</div><div class="line">        String text;</div><div class="line">        try &#123;</div><div class="line">            //死循环监听</div><div class="line">            while (true) &#123;</div><div class="line">                //响应客户端连接请求</div><div class="line">                client = responseSocket();</div><div class="line">                while (true) &#123;</div><div class="line">                    //接收客户端发送的消息</div><div class="line">                    text = receiveMsg(client);</div><div class="line">                    //显示消息结果</div><div class="line">                    makeTips(text);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                closeSocket(client);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 关闭连接及缓存</div><div class="line">     *</div><div class="line">     * @param client</div><div class="line">     */</div><div class="line">    private void closeSocket(Socket client) throws IOException &#123;</div><div class="line">        reader.close();</div><div class="line">//        writer.close();</div><div class="line">        client.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 发送消息到客户端</div><div class="line">     *</div><div class="line">     * @param client</div><div class="line">     * @param text</div><div class="line">     */</div><div class="line">    private void sendMsg(Socket client, String text) throws IOException &#123;</div><div class="line">        writer = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));</div><div class="line">        writer.write(text + &quot;\n&quot;);</div><div class="line">        writer.flush();//发送</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 提示</div><div class="line">     *</div><div class="line">     * @param text</div><div class="line">     */</div><div class="line">    private void makeTips(String text) &#123;</div><div class="line">        Message msg = new Message();</div><div class="line">        Bundle bundle = new Bundle();</div><div class="line">        bundle.putString(ChatServer.MSG_KEY, text);</div><div class="line">        msg.setData(bundle);</div><div class="line">        msg.what = SERVER_TAG;</div><div class="line">        handler.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String receiveMsg(Socket client) throws IOException &#123;</div><div class="line">        reader = new BufferedReader(new InputStreamReader(client.getInputStream()));</div><div class="line">        String result = reader.readLine();</div><div class="line">        return &quot;服务器收到:&quot; + result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Socket responseSocket() throws IOException &#123;</div><div class="line">        return server.accept();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ChatClient.java</div><div class="line">public class ChatClient &#123;</div><div class="line">    private Socket socket = null;</div><div class="line"></div><div class="line">    public ChatClient(String host, int port) throws IOException &#123;</div><div class="line">        socket = new Socket(host, port);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 向服务器端发送消息</div><div class="line">     *</div><div class="line">     * @param msg</div><div class="line">     * @throws IOException</div><div class="line">     */</div><div class="line">    public void sendMsg(String msg) throws IOException &#123;</div><div class="line">        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</div><div class="line">        writer.write(msg.replace(&quot;\n&quot;, &quot;&quot;) + &quot;\n&quot;);</div><div class="line">        writer.flush();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">MainActivity.java</div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    Handler handler = new Handler() &#123;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            switch (msg.what) &#123;</div><div class="line">                case ChatServer.SERVER_TAG:</div><div class="line">                    Bundle bundle = msg.getData();</div><div class="line">                    Toast.makeText(MainActivity.this, bundle.getString(ChatServer.MSG_KEY), Toast.LENGTH_LONG).show();</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        launchServer();</div><div class="line">        launchClient();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void launchServer() &#123;</div><div class="line">        //启动服务器端</div><div class="line">        try &#123;</div><div class="line">            ChatServer</div><div class="line">                    chatServer = new ChatServer(handler);</div><div class="line">            chatServer.start();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 启动客户端</div><div class="line">     */</div><div class="line">    private void launchClient() &#123;</div><div class="line">        new Thread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                ChatClient client = null;</div><div class="line">                try &#123;</div><div class="line">                    client = new ChatClient(null, ChatServer.PORT);</div><div class="line">                    client.sendMsg(&quot;客户端给服务器端，发了一条信息&quot;);</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android进阶 - View 工作原理探究]]></title>
      <url>http://yoursite.com/2016/10/23/View%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 探究分析了View绘制的总体流程：onMeasure、onLayout、onDraw三大方法。<a id="more"></a></p>
<h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><h3 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h3><p>ViewRoot对应<strong>ViewRootImpl</strong>类，是连接WindowManager与<strong>DecorView</strong>的纽带。View的<strong>三大流程</strong>都是通过<strong>ViewRoot</strong>完成的。ActivityThread中，Activity对象被回收时，会将<strong>DecorView</strong>添加到Window中，同时创建<strong>ViewRootImpl</strong>对象，并将ViewRootImpl对象和DecorView对象建立关联。<br>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建ViewRootImpl对象</span></div><div class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(),display);</div><div class="line"><span class="comment">//添加关联</span></div><div class="line">root.setView(view,wparams,panelparentView);</div></pre></td></tr></table></figure></p>
<p>View绘制流程：从ViewRoot的<strong>performTraversals</strong>开始，经过measure、layout、draw三大流程后才将View绘制出来。<br><strong>performTraversals</strong>方法（8W多行代码），会依次调用performMeasure、performLayout、performDraw方法（这三个方法分别完成顶级View - DecorView 的measure、layout、draw方法）</p>
<p>其中performMeasure方法会调用measure方法，在measure方法中又会调用onMeasure方法，onMeasure方法则会对所有子元素进行measure，从而达到measure流程从父容器传递到子元素中的目的。接着子元素会重复父容器的measure过程，如此反复完成整个View树的遍历。</p>
<p>最后，perfromLayout、performDraw的传递过程也是类似的，唯一不同，而performDraw的传递过程在draw方法中通过dispatchDraw来实现。</p>
<h3 id="DecorView-继承FrameLayout"><a href="#DecorView-继承FrameLayout" class="headerlink" title="DecorView - 继承FrameLayout"></a>DecorView - 继承FrameLayout</h3><p>DecorView作为顶级View，一般情况下会包含一个LinearLayout，该LinearLayout分为上下两部分，titlebar部分、android.R.id.content部分（所以，setContentView方法其实就是将布局添加到id为content的<strong>FrameLayout</strong>中）正如小标题，DecorView本质是FrameLayout，View层时间都必先经过DecorView然后在传递给其中的View。</p>
<h3 id="MeasureSpec-很大程度决定View的尺寸规格"><a href="#MeasureSpec-很大程度决定View的尺寸规格" class="headerlink" title="MeasureSpec - 很大程度决定View的尺寸规格"></a>MeasureSpec - 很大程度决定View的尺寸规格</h3><p>MeasureSpec代表一个32位int值，高2位代表SpecMode（测量模式），低30位代表SpecSize（规格大小）<br><strong>小白科普：</strong>Java中int为4个字节，Android使用第一个高位字节存储Mode，剩下三个字节存储Size</p>
<p>MeasureSpec内部实现原理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">//下面是三种测量模式</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 父控件不对子控件施加任何约束，一般用于系统内部</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 父控件已为子控件指定精确大小，对应于LayoutParams中的 match_parenet和具体数值这两种模式</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 子控件可随意大小，但不可大于父控件大小，对应于LayoutParams中的 wrap_content</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据提供的测量模式以及大小创建 measure specification</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p><strong>小白科普：</strong>&lt;&lt; 是移位运算，3&lt;&lt;30表示的是首先把3变成二进制的11然后右边补30个0所组成的一个二进制的数。</p>
<p><strong>MearsureSpec和LayoutParams对应关系</strong><br>系统内部是通过MeasureSpec进行View测量的，但正常情况下，都是使View指定MeasureSpec。View测量时候系统会将<strong>LayoutParams</strong>在父容器约束下<strong>转换</strong>成对应的<strong>MeasureSpec</strong>，然后再根据这个MeasureSpec来确定View测量后的宽高。因此，Measure需要由LayoutParams和父容器一起决定。</p>
<p>另外，对于顶级View（DecorView），其MeasureSpec由窗口尺寸和其自身的LayoutParams共同决定。Measure一旦决定后，onMeasure中in个即可获得View的测量宽高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* DecorView中，MeasureSpec产生过程</div><div class="line">* 根据LayoutParams划分，并产生MeasureSpec</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> measureSpec;</div><div class="line">        <span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            <span class="comment">// Window can't resize. Force root view to be windowSize.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            <span class="comment">// Window can resize. Set max size for root view.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对于普通View（布局中的View），View的measure方法需要由ViewGroup传递过来<br>再看看ViewGroup中的measureChildWithMargins方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></div><div class="line">         <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</div><div class="line">         <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed) &#123;</div><div class="line">     <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">             mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                     + widthUsed, lp.width);</div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">             mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                     + heightUsed, lp.height);</div><div class="line"></div><div class="line">     child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>上述方法，对子元素进行measure，调哟in个子元素measure之前会获取子元素的MeasureSpec。显然，<strong>子元素MeasureSpec的创建与父容器的MeasureSpec和子元素本身的LayoutParams有关，还与View的margin以及padding有关</strong>（具体需要研究ViewGroup的getChildMeasureSpec方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> resultSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> resultMode = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="comment">// Parent has imposed an exact size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size. So be it.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent has imposed a maximum size on us</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... so be it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size, but our size is not fixed.</span></div><div class="line">                <span class="comment">// Constrain child to not be bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></div><div class="line">                <span class="comment">// bigger than us.</span></div><div class="line">                resultSize = size;</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Parent asked to see how big we want to be</span></div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// Child wants a specific size... let him have it</span></div><div class="line">                resultSize = childDimension;</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</div><div class="line">                <span class="comment">// Child wants to be our size... find out how big it should</span></div><div class="line">                <span class="comment">// be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</div><div class="line">                <span class="comment">// Child wants to determine its own size.... find out how</span></div><div class="line">                <span class="comment">// big it should be</span></div><div class="line">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</div><div class="line">                resultMode = MeasureSpec.UNSPECIFIED;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>上述方法，主要根据<strong>父容器的MeasureSpec同时结合View本身的LayoutParams</strong>来确定子元素的MeasureSpec。<br>另外注意，子元素可用大小为父容器尺寸减去padding。</p>
<h2 id="View工作流程"><a href="#View工作流程" class="headerlink" title="View工作流程"></a>View工作流程</h2><p>measure 确定View宽高<br>layout确定View最终宽高和四个顶点位置<br>draw将View绘制到屏幕</p>
<h3 id="View的生命周期与工作流程"><a href="#View的生命周期与工作流程" class="headerlink" title="View的生命周期与工作流程"></a>View的生命周期与工作流程</h3><p><strong>View生命周期示意图</strong><br><img src="http://upload-images.jianshu.io/upload_images/1513860-dfc8ddeb8b158531?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View生命周期"></p>
<p><strong>View工作流程示意图</strong><br><img src="http://upload-images.jianshu.io/upload_images/1513860-ec0a009e7143a802?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View工作流程"></p>
<h3 id="探究Measure过程"><a href="#探究Measure过程" class="headerlink" title="探究Measure过程"></a>探究Measure过程</h3><p>两种情况，若只是一个原始的View，通过measure方法就完成了测量过程；如果是ViewGroup，除了完成自身的measure过程，还需要遍历子元素的measure方法，各个子元素<strong>递归</strong>去执行这个部分。（如上面的示意图所述）</p>
<p>View的measure方法是一个final类型的方法 - 意味着子类不能重写该方法,因此仔细研究onMeasure方法的实现效果会更好。</p>
<p>这里贴出View中Measure方法，有部分注释，供有兴趣的读者阅读研究。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* View中的Measure方法</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//先判断当前Mode是不是特例LAYOUT_MODE_OPTICAL_BOUNDS</span></div><div class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">            Insets insets = getOpticalInsets();</div><div class="line">            <span class="keyword">int</span> oWidth  = insets.left + insets.right;</div><div class="line">            <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</div><div class="line">            widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</div><div class="line">            heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></div><div class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</div><div class="line">        <span class="keyword">if</span> (mMeasureCache == <span class="keyword">null</span>) mMeasureCache = <span class="keyword">new</span> LongSparseLongArray(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</div><div class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// first clears the measured dimension flag</span></div><div class="line">            mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</div><div class="line"></div><div class="line">            resolveRtlPropertiesIfNeeded();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</div><div class="line">                    mMeasureCache.indexOfKey(key);</div><div class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</div><div class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></div><div class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</div><div class="line">                <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></div><div class="line">                setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</div><div class="line">                mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></div><div class="line">            <span class="comment">// an exception to warn the developer</span></div><div class="line">            </div><div class="line">            <span class="comment">//如果自定义View重写了onMeasure方法而没有调用setMeasureDimension()方法,将会在这里抛出异常</span></div><div class="line">            <span class="comment">//判断原理：通过解析状态位mPrivateFlags，setMeasureDimension()方法会将mPrivateFlags设置为已计算状态（PFLAG_MEASURED_DIMENSION_SET），只需要检查mPrivateFlags是否含有PFLAG_MEASURED_DIMENSION_SET即可。</span></div><div class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></div><div class="line">                        + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></div><div class="line">                        + <span class="string">" measured dimension by calling"</span></div><div class="line">                        + <span class="string">" setMeasuredDimension()"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">        mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line">        </div><div class="line">        <span class="comment">//计算出的key作为键，量算结果作为值，将该键值对放入成员变量mMeasureCache中,实现本次计算结果的环缓存</span></div><div class="line">        mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</div><div class="line">                (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>好啦，接下来，继续研究onMeasure</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* View中的onMeasure方法</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>setMeasuredDimension()方法会设置View宽高测量值，接下来进一步深入，研究getDefaultSize()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* View中的getDefaultSize方法</div><div class="line">*/</div><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">        int result = size;</div><div class="line">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (specMode) &#123;</div><div class="line">        case MeasureSpec.UNSPECIFIED://一般是系统内部的测量过程，重点注意另外两种模式</div><div class="line">            result = size;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.AT_MOST://这两种模式都是做一样的事情</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>getDefaultSize方法直接就是根据测量模式返回measureSpec中的specSize，而这个specSize就是<strong>View测量后的大小</strong>。</p>
<p><strong>注意：</strong>View测量后大小 与 View最终大小 需要区分，是<strong>两个东西</strong>，因为View最终大小是在<strong>layout阶段</strong>确定的，但<strong>两者几乎所有情况都是相等的</strong>。</p>
<p>接下来，再继续探究getDefaultSize方法的第一个参数，从onMeasure方法中可知，该参数来源于下面两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上述两个方法实现原理都一致，判断有没有背景，如果有，返回两者较大的宽高，没有则返回自己的宽高（android:minwith这个属性指定的值）。</p>
<p>那么，问题来了，背景最小宽高原理是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> intrinsicWidth = getIntrinsicWidth();</div><div class="line">        <span class="keyword">return</span> intrinsicWidth &gt; <span class="number">0</span> ? intrinsicWidth : <span class="number">0</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中可见，Drawable的原始宽度，如果没有原始宽度，则返回0。</p>
<p><strong>小白科普：</strong>ShapeDrawable无原始宽高，而BimapDrawable有原始宽高（即图片尺寸）</p>
<p><strong>再谈谈ViewGroup的measure过程</strong><br>主要区别：</p>
<ol>
<li>除了完成自己measure过程还要遍历调用子元素的measure方法，各个子元素再递归执行该过程。</li>
<li>ViewGroup是抽象类，没有重写View的onMeasure方法，而是提供了一个measureChildren的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line">            <span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>View在measure过程中会对每一个子元素进行measure。<br>再细说下，measureChild方法的思路：</p>
<ol>
<li>取出子元素的LayoutParams</li>
<li>通过getChildMeasureSpec离开创建子元素的MeasureSpec</li>
<li>将MeasureSpec传递给View的Measure方法进行测量。</li>
</ol>
<p><strong>问题：为什么ViewGroup不像View一样对其onMeasure方法做统一实现？</strong><br>因为不同的ViewGroup子类会有不同的特性，因此其中的onMeasure细节不相同。</p>
<p><strong>获取View宽高方法不当，可能会获取错误。</strong><br><strong>原因：</strong>View的<strong>measure过程</strong>和<strong>Activity生命周期</strong>方法执行顺序是<strong>不确定的</strong>，无法保证Activity执行了onCreate、onStart、onReasume时，View测量完毕。</p>
<p><strong>如果View还没有完成测量，则获取的宽高会是0</strong><br>给出四种方法解决：</p>
<ol>
<li>onWindowFocusChanged - 该方法被调用时候，View已经测量完毕，能够正确获取View宽高。<br>注意:该方法会被调用多次，Activity窗口得到焦点与失去焦点时均会被调用一次（继续执行，暂停执行）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void onWindowFocusChanged(boolean hasWindowFocus) &#123;</div><div class="line">        super.onWindowFocusChanged(hasWindowFocus);</div><div class="line">        if(hasWindowFocus)&#123;</div><div class="line">        //获取宽高</div><div class="line">        int with = view.getMeasuredWidth();</div><div class="line">        int height = view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>view.post(runnable)<br>通过post将一个runnable投递到消息队列队尾，等待Looper调用此runnable时，View已初始化完毕。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    view.post(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//获取宽高</span></div><div class="line">        <span class="keyword">int</span> with = view.getMeasuredWidth();</div><div class="line">        <span class="keyword">int</span> height = view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>ViewTreeObserver<br>该类有众多回调接口，其中的OnGlobalLayoutListener接口，当View树状态发生变化或者View树内部的View的可见性发生改变，该方法都会被回调，利用此特性，可获得宽高。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    viewTreeObserver observer = view.getViewTreeObserver();</div><div class="line">    observer.addOnGlobalLayoutListener(<span class="keyword">new</span> OnGlobalListener()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span></span>&#123;</div><div class="line">        view.getViewTreeObserver().removeGlobalOnlayoutListener(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//获取宽高</span></div><div class="line">        <span class="keyword">int</span> with = view.getMeasuredWidth();</div><div class="line">        <span class="keyword">int</span> height = view.getMeasuredHeight();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>view.measure(int widthMeasureSpec,int heightMeasureSpec)<br>手动对View进行获取，根据View的LayoutParams不同，而采取不同手段。（因不常用，这里就不详细说明）</li>
</ul>
<h3 id="探究layout过程"><a href="#探究layout过程" class="headerlink" title="探究layout过程"></a>探究layout过程</h3><p>layout主要作用是ViewGroup用来确定子元素位置（递归）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">       if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</div><div class="line">           onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">           mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       //设定四个顶点位置</div><div class="line">       int oldL = mLeft;</div><div class="line">       int oldT = mTop;</div><div class="line">       int oldB = mBottom;</div><div class="line">       int oldR = mRight;</div><div class="line"></div><div class="line">       boolean changed = isLayoutModeOptical(mParent) ?</div><div class="line">               setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">       if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">           onLayout(changed, l, t, r, b);</div><div class="line">           mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">           ListenerInfo li = mListenerInfo;</div><div class="line">           if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</div><div class="line">               ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                       (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">               int numListeners = listenersCopy.size();</div><div class="line">               for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class="line">                   listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">       mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><strong>layout方法流程：</strong></p>
<ol>
<li>setFrame方法设定View四个顶点位置</li>
<li>调用onLayout方法，父容器确定子元素位置<br>另外，与onMeasure方法相似，onLayout方法也是各不相同的。</li>
</ol>
<p>onLayout方法（LinearLayout、RelativeLayout等基本控件可自行尝试研究下）</p>
<h3 id="探究draw过程"><a href="#探究draw过程" class="headerlink" title="探究draw过程"></a>探究draw过程</h3><p>draw主要作用是将View绘制到屏幕上<br>绘制过程：</p>
<ol>
<li>绘制背景(background.draw(canvas))</li>
<li>绘制自己(onDraw)</li>
<li>绘制children(dispatchDraw)</li>
<li>绘制装饰(onDrawScrollBars)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* View中的draw方法</div><div class="line">*/</div><div class="line">public void draw(Canvas canvas) &#123;</div><div class="line">        final int privateFlags = mPrivateFlags;</div><div class="line">        final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</div><div class="line">                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line"></div><div class="line">        /*</div><div class="line">         * Draw traversal performs several drawing steps which must be executed</div><div class="line">         * in the appropriate order:</div><div class="line">         *</div><div class="line">         *      1. Draw the background</div><div class="line">         *      2. If necessary, save the canvas&apos; layers to prepare for fading</div><div class="line">         *      3. Draw view&apos;s content</div><div class="line">         *      4. Draw children</div><div class="line">         *      5. If necessary, draw the fading edges and restore layers</div><div class="line">         *      6. Draw decorations (scrollbars for instance)</div><div class="line">         */</div><div class="line"></div><div class="line">        // Step 1, draw the background, if needed</div><div class="line">        int saveCount;</div><div class="line"></div><div class="line">        if (!dirtyOpaque) &#123;</div><div class="line">            drawBackground(canvas);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // skip step 2 &amp; 5 if possible (common case)</div><div class="line">        final int viewFlags = mViewFlags;</div><div class="line">        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</div><div class="line">        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</div><div class="line">        if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">            // Step 3, draw the content</div><div class="line">            if (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">            // Step 4, draw the children</div><div class="line">            dispatchDraw(canvas);</div><div class="line"></div><div class="line">            // Overlay is part of the content and draws beneath Foreground</div><div class="line">            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">                mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Step 6, draw decorations (foreground, scrollbars)</div><div class="line">            onDrawForeground(canvas);</div><div class="line"></div><div class="line">            // we&apos;re done...</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /*</div><div class="line">         * Here we do the full fledged routine...</div><div class="line">         * (this is an uncommon case where speed matters less,</div><div class="line">         * this is why we repeat some of the tests that have been</div><div class="line">         * done above)</div><div class="line">         */</div><div class="line"></div><div class="line">        boolean drawTop = false;</div><div class="line">        boolean drawBottom = false;</div><div class="line">        boolean drawLeft = false;</div><div class="line">        boolean drawRight = false;</div><div class="line"></div><div class="line">        float topFadeStrength = 0.0f;</div><div class="line">        float bottomFadeStrength = 0.0f;</div><div class="line">        float leftFadeStrength = 0.0f;</div><div class="line">        float rightFadeStrength = 0.0f;</div><div class="line"></div><div class="line">        // Step 2, save the canvas&apos; layers</div><div class="line">        int paddingLeft = mPaddingLeft;</div><div class="line"></div><div class="line">        final boolean offsetRequired = isPaddingOffsetRequired();</div><div class="line">        if (offsetRequired) &#123;</div><div class="line">            paddingLeft += getLeftPaddingOffset();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int left = mScrollX + paddingLeft;</div><div class="line">        int right = left + mRight - mLeft - mPaddingRight - paddingLeft;</div><div class="line">        int top = mScrollY + getFadeTop(offsetRequired);</div><div class="line">        int bottom = top + getFadeHeight(offsetRequired);</div><div class="line"></div><div class="line">        if (offsetRequired) &#123;</div><div class="line">            right += getRightPaddingOffset();</div><div class="line">            bottom += getBottomPaddingOffset();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final ScrollabilityCache scrollabilityCache = mScrollCache;</div><div class="line">        final float fadeHeight = scrollabilityCache.fadingEdgeLength;</div><div class="line">        int length = (int) fadeHeight;</div><div class="line"></div><div class="line">        // clip the fade length if top and bottom fades overlap</div><div class="line">        // overlapping fades produce odd-looking artifacts</div><div class="line">        if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</div><div class="line">            length = (bottom - top) / 2;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // also clip horizontal fades if necessary</div><div class="line">        if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</div><div class="line">            length = (right - left) / 2;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (verticalEdges) &#123;</div><div class="line">            topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));</div><div class="line">            drawTop = topFadeStrength * fadeHeight &gt; 1.0f;</div><div class="line">            bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));</div><div class="line">            drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (horizontalEdges) &#123;</div><div class="line">            leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));</div><div class="line">            drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f;</div><div class="line">            rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));</div><div class="line">            drawRight = rightFadeStrength * fadeHeight &gt; 1.0f;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        saveCount = canvas.getSaveCount();</div><div class="line"></div><div class="line">        int solidColor = getSolidColor();</div><div class="line">        if (solidColor == 0) &#123;</div><div class="line">            final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</div><div class="line"></div><div class="line">            if (drawTop) &#123;</div><div class="line">                canvas.saveLayer(left, top, right, top + length, null, flags);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (drawBottom) &#123;</div><div class="line">                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (drawLeft) &#123;</div><div class="line">                canvas.saveLayer(left, top, left + length, bottom, null, flags);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (drawRight) &#123;</div><div class="line">                canvas.saveLayer(right - length, top, right, bottom, null, flags);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            scrollabilityCache.setFadeColor(solidColor);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Step 3, draw the content</div><div class="line">        if (!dirtyOpaque) onDraw(canvas);</div><div class="line"></div><div class="line">        // Step 4, draw the children</div><div class="line">        dispatchDraw(canvas);</div><div class="line"></div><div class="line">        // Step 5, draw the fade effect and restore layers</div><div class="line">        final Paint p = scrollabilityCache.paint;</div><div class="line">        final Matrix matrix = scrollabilityCache.matrix;</div><div class="line">        final Shader fade = scrollabilityCache.shader;</div><div class="line"></div><div class="line">        if (drawTop) &#123;</div><div class="line">            matrix.setScale(1, fadeHeight * topFadeStrength);</div><div class="line">            matrix.postTranslate(left, top);</div><div class="line">            fade.setLocalMatrix(matrix);</div><div class="line">            p.setShader(fade);</div><div class="line">            canvas.drawRect(left, top, right, top + length, p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawBottom) &#123;</div><div class="line">            matrix.setScale(1, fadeHeight * bottomFadeStrength);</div><div class="line">            matrix.postRotate(180);</div><div class="line">            matrix.postTranslate(left, bottom);</div><div class="line">            fade.setLocalMatrix(matrix);</div><div class="line">            p.setShader(fade);</div><div class="line">            canvas.drawRect(left, bottom - length, right, bottom, p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawLeft) &#123;</div><div class="line">            matrix.setScale(1, fadeHeight * leftFadeStrength);</div><div class="line">            matrix.postRotate(-90);</div><div class="line">            matrix.postTranslate(left, top);</div><div class="line">            fade.setLocalMatrix(matrix);</div><div class="line">            p.setShader(fade);</div><div class="line">            canvas.drawRect(left, top, left + length, bottom, p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (drawRight) &#123;</div><div class="line">            matrix.setScale(1, fadeHeight * rightFadeStrength);</div><div class="line">            matrix.postRotate(90);</div><div class="line">            matrix.postTranslate(right, top);</div><div class="line">            fade.setLocalMatrix(matrix);</div><div class="line">            p.setShader(fade);</div><div class="line">            canvas.drawRect(right - length, top, right, bottom, p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        canvas.restoreToCount(saveCount);</div><div class="line"></div><div class="line">        // Overlay is part of the content and draws beneath Foreground</div><div class="line">        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</div><div class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Step 6, draw decorations (foreground, scrollbars)</div><div class="line">        onDrawForeground(canvas);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>View的绘制过程传递是通过dispatchDraw来实现，dispatchDraw会遍历所有子元素的draw方法，另外，View还有一个特殊的方法setWillNotDraw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void setWillNotDraw(boolean willNotDraw) &#123;</div><div class="line">        setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>setFlags - 该方法可设置优化标记<br>如果View不需要绘制任何内容，那么将设置标记为true，系统会相应优化。默认情况下，View不启用这个标记位，但ViewGroup会默认启动该优化标记。<br>而实际开发意义：当我们自定义控件继承于ViewGroup并且本身不具备绘制功能，则开启标记。而如果明确知道一个ViewGroup需要通过onDraw来绘制内容时候，则需要显式关闭WILL_NOT_DRAW这个标记位。</p>
]]></content>
      
        
        <tags>
            
            <tag> Android进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java进阶 - 线程探索]]></title>
      <url>http://yoursite.com/2016/10/15/Java%E8%BF%9B%E9%98%B6%20-%20%E7%BA%BF%E7%A8%8B%E6%8E%A2%E7%B4%A2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 深入浅出，对Java多线程的探索 - 笔者的一段学习笔记，如果错漏，恳请指教。<a id="more"></a></p>
<h2 id="前提概念"><a href="#前提概念" class="headerlink" title="前提概念"></a>前提概念</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>概念：一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>
<li>加锁可以保证复合语句的原子性，<code>sychronized</code>可以保证多条语句在<code>synchronized</code>块中语意上是原子的。由<strong>Java内存模型</strong>来直接保证的原子性变量操作包括read、load、use、assign、store和write六个，大致可以认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock与unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐匿地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—synchronized关键字，因此在synchronized块之间的操作也具备原子性。</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul>
<li>概念：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。</li>
<li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。</li>
<li>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的，而final关键字的可见性是指：被final修饰的字段是构造器一旦初始化完成，并且构造器没有把“this”引用传递出去，那么在其它线程中就能看见final字段的值。</li>
</ul>
<h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><ul>
<li>概念：程序执行的顺序按照代码的先后顺序执行。（JVM真正执行代码时候，为了提高程序运行效率，可能对输入的代码进行优化，不能保证程序中各个语句执行先后顺序与代码一致，但能保证程序最终运行结果与代码顺序执行结果一致）Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。<br> Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则来获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</li>
</ul>
<h3 id="并行、并发以及线程安全"><a href="#并行、并发以及线程安全" class="headerlink" title="并行、并发以及线程安全"></a>并行、并发以及线程安全</h3><ul>
<li>并行：真正的同时执行（同一时刻可以多个进程执行）</li>
<li>并发：通过CPU调度算法，不是真正的同时执行（同一时刻最多只有一个进程在执行）</li>
<li>线程安全：并发情况下，某代码经过多线程调用，而线程调用顺序不影响操作结果（火车卖票问题，多处卖票，保证一票一卖）</li>
<li>同步：Synchronized 关键字，通过人为控制和调度，保证共享资源的多线程访问的线程安全；<strong><effective java="">：</effective></strong>①同步不仅可以阻止一个线程<strong>看到对象处于不一致的状态</strong>中，②它还可以保证进入同步方法或者同步代码块的每个线程，都看到<strong>同一个锁保护的之前</strong>所有的修改结果</li>
<li>Volatile 关键字：<strong>轻量级的synchronized</strong>，对比synchronized，volatile变量所需编码更少，并且运行开销也会较少。Volatile 读操作开销很小，如果读操作远远大于写操作，单独使用Volatile可以提供优于锁的性能优势。（后面会与大家一同对该关键字进行探讨）</li>
</ul>
<h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><h4 id="保证原子性"><a href="#保证原子性" class="headerlink" title="保证原子性"></a>保证原子性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">10</span>;<span class="comment">//1</span></div><div class="line">y = x;<span class="comment">//2</span></div><div class="line">x++;<span class="comment">//3</span></div><div class="line">x = x + <span class="number">1</span>;<span class="comment">//4</span></div></pre></td></tr></table></figure>
<p>只有语句1是原子性操作 - 语句1直接将10赋值给x（将数值10写入工作内存）；语句2包含两个原子性操作（读x值，将x写入内存），合起来就不是原子性操作了（因为可能中间会被打断，造成一个有效，一个无效的情况，语句3，4也是同理）；语句3包含3个操作（读x值，加1，写入内存）</p>
<p><strong>总结：</strong>只有简单的读取、赋值才是原子操作（必须是将具体数值赋值给某个变量，变量之间的赋值不是原子操作）；Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围的原子性，需要通过synchronized和lock来实现（保证任意时刻只有一个线程执行对应代码块）</p>
<h4 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h4><p>volatile关键字可保证可见性：当一个共享变量被volatile修饰时，它会保证修改的值会立即更新到主存，当有其他线程需要读取，它会去内存中读取新值。（当然，synchronized、Lock 也可以保证）</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>synchronized、lock通过保证线程同步，自然保证了有序性。另外，通过volatile关键字也可保证一定的“有序性”（具体原理稍候再描述）</p>
<p>注意：Java内存模型中，如果操作遵循<strong>“先行发生原理”（happens-before）</strong>，则不需要通过任何手段就可以保证有序性。</p>
<p>先行发生原则（happens-before）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>前四条主要规则解释：</p>
<ul>
<li>第一条：在单线程中，程序执行看起来是有序的（因为在保证执行结果一致的前提下，虚拟机可能会对程序代码进行重排序 - 也就是仅对不存在数据依赖性的指令进行重排序）</li>
<li>第二条： 如果锁处于锁定状态，那么必须对锁进行释放，后面才能继续进行lock操作</li>
<li>第三条： 如果某线程写入一个变量，另外一个线程去读取，那么，写入操作必须要在读取操作之前</li>
<li>第四题： 显而易见的传递性</li>
</ul>
<h3 id="探讨Volatile关键字"><a href="#探讨Volatile关键字" class="headerlink" title="探讨Volatile关键字"></a>探讨Volatile关键字</h3><p><strong>文章及书本推荐：</strong></p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" title="Volatile 关键字" target="_blank" rel="external">正确使用 Volatile 变量</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" title="volatile关键字解析" target="_blank" rel="external">Volatile关键字解析</a></li>
<li>《深入理解 Java 虚拟机》- 周志明（著）<h4 id="volatile-关键字两层含义"><a href="#volatile-关键字两层含义" class="headerlink" title="volatile 关键字两层含义"></a>volatile 关键字两层含义</h4><strong> 1. 保证了不同线程对该变量的可见性</strong><br>  注意：volatile 变量在各个线程的工作内存中，可以存在不一致的情况，但由于每次使用都要先刷新，执行引擎看不到不一致的情况，因此可认为不存在一致性问题，但java中运算操作并不是原子性操作，导致volatile变量的运算在并发状态下一样是不安全的，下面尝试用代码说明。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearningVolatile</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        race++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</div><div class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</div><div class="line">                        increase();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            threads[i].start();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 等待所有累加线程结束</span></div><div class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>) &#123;</div><div class="line">            Thread.yield();</div><div class="line">        &#125;</div><div class="line">        System.out.println(race);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//每次运行结果不同，总为一个小于200000的数字</span></div><div class="line"><span class="comment">//笔者数次输出结果为：73000+</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代码剖析：</strong><br>如果正确并发，理论结果应为200000，显然，这段程序并没有正确并发，使用javap 命令反编译得到字节码。可以看到，race++ 一行代码包含：取值（getstatic-volatile保证，此时取race值的正确性）、将常量压入栈（iconst_1）、（将两个栈顶int值相加并压入栈顶）iadd，写入（putstatic），就如上面解析的一样，这一系列操作合起来，就不再符合原子性了，当取值之后，其他线程可能已经把race加大了，本线程的race值则变成过期数据，最后写入错误的race值到主内存中。<br>另：其实采用字节码来分析，也是欠缺严谨的，即使编译出来只有一条字节码，也并不代表该指令就是一个原子操作（因为一条字节码执行时候，解析器还是要运行多行代码才可以实现它的语义，使用 -XX:+PrintAssembly参数输出反汇编来分析会更加严谨），但这里字节码已经能够说明问题，可不必再深入细究。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//反编译字节码（increase方法）</div><div class="line">  public static void increase();</div><div class="line">    Code:</div><div class="line">       0: getstatic     #2                  // Field race:I</div><div class="line">       3: iconst_1</div><div class="line">       4: iadd</div><div class="line">       5: putstatic     #2                  // Field race:I</div><div class="line">       8: return</div></pre></td></tr></table></figure></p>
<p><strong>volatile 主要适用场景：</strong></p>
<ol>
<li>运算结果不依赖变量当前值，能够确保只有单一线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ol>
<p><strong> 2. 保证了不同线程对该变量的可见性</strong><br>     关键需要理解：为何指令重排序会干扰程序的并发执行？<br>   例子：初始化完成的标识，如果指令重排，可能会导致 <code>initialized = true</code>提前执行，使B线程运行出现问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">A线程中</div><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</div><div class="line">XXX x = <span class="keyword">new</span> XXX();<span class="comment">//模拟初始化</span></div><div class="line">...</div><div class="line">initialized = <span class="keyword">true</span>;<span class="comment">//说明初始化完成</span></div><div class="line">B线程中</div><div class="line"><span class="keyword">while</span>（！initialized）&#123;</div><div class="line">sleep();</div><div class="line">&#125;</div><div class="line">doSomethingWithAConfig();<span class="comment">//接下来，就可以利用A中初始好的配置信息进行操作啦</span></div></pre></td></tr></table></figure></p>
<h3 id="Java-monitor（同步机制）"><a href="#Java-monitor（同步机制）" class="headerlink" title="Java monitor（同步机制）"></a>Java monitor（同步机制）</h3><ul>
<li>推荐文章：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-synchronized/" title="探索Java同步机制" target="_blank" rel="external">探索Java同步机制</a></li>
<li>概念：Java Monitor 从两个方面来支持线程之间的同步，即：互斥执行与协作。Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行 , 使用 notify/notifyAll/wait 方法来协同不同线程之间的工作。这些方法在 Object 类上被定义，会被所有的 Java 对象自动继承。<br>实质上，Java 的 Object 类本身就是监视者对象，Java 语言对于这样一个典型并发设计模式做了内建的支持。<br><img src="http://odzvmv4ab.bkt.clouddn.com/java%20monitor%E5%9B%BE%E8%A7%A3.jpg" alt="" title="java monitor图解"><h2 id="线程探索"><a href="#线程探索" class="headerlink" title="线程探索"></a>线程探索</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul>
<li>ThreadState：NEW、RUNNABLE、BLOCKED、WAITTING、TIMED_WAITING、TERMINATED<ul>
<li>NEW：线程还没 start 时候</li>
<li>RUNNABLE：线程在 JVM 中执行时候</li>
<li>BLOCKED：线程等待监控锁时候（阻塞）</li>
<li>WAITTING：线程不确定时长等待另外一个线程进行一个实际操作时候</li>
<li>TIMED_WAITING：线程正在等待另外一个线程进行操作，直到特定的时间结束时候</li>
<li>TERMINATED：线程已退出</li>
</ul>
</li>
<li>状态转换图（join - 阻塞当前执行进程，直到调用该方法的线程执行完毕才释放、yield - 让出当前执行位置，让其他线程执行，与join方法恰好相反）<br><img src="http://odzvmv4ab.bkt.clouddn.com/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg" alt=""><br>注意：<strong>join、sleep方法</strong>与<strong>wait、synchronized方法</strong> 不同。<ul>
<li>join、sleep恢复时，线程从阻塞状态回到RUNNABLE状态，等待JVM调度 — <strong>阻塞 -&gt; 可运行</strong></li>
<li>wait方法，使线程处于等待池（wait blocked pool），直到notify/notifyAll方法唤醒线程，将被唤醒的线程放到锁定池（lock blocked pool），释放同步锁使线程回到RUNNABLE状态— <strong>等待池 -&gt; 锁定池 -&gt; 可运行</strong></li>
<li>synchronized 同步锁，则使线程进入锁定池（lock blocked pool），待释放同步锁再回到RUNNABLE状态— <strong>锁定池 -&gt; 可运行</strong></li>
<li>yield方法，使RUNNING状态的线程进入RUNNABLE状态</li>
<li>RUNNABLE状态下，线程调度顺序不一定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程类相关"><a href="#线程类相关" class="headerlink" title="线程类相关"></a>线程类相关</h3><p>主要的线程相关类：Thread类、Runnable接口、Callable接口、Future类</p>
<h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><p>Thread类实现了Runnable接口，常用的Thread类相关方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">start();<span class="comment">//启动线程</span></div><div class="line">yield();<span class="comment">//让出CPU，让其他就绪状态（RUNNABLE）的线程运行</span></div><div class="line">sleep();<span class="comment">//停滞，使线程进入阻塞状态，但不能改变对象的机锁（仍持有对象锁，其他线程不可访问该对象），注意与wait()方法区分</span></div><div class="line">wait();<span class="comment">//等待，释放对象锁（其他线程可访问），因此必须要放到 synchronized 代码块中，否则会抛出“java.lang.IllegalMonitorStateException”异常，使用notify或者noyifyAll方法来唤醒当前等待池中的线程</span></div><div class="line">join();<span class="comment">//阻塞当前执行的线程，直到调用该方法的线程执行完毕才释放</span></div><div class="line">interrupte();<span class="comment">//检查当前线程是否被打断（返回boolean类型）</span></div><div class="line">interrupted();<span class="comment">//将中断状态标识置为true</span></div></pre></td></tr></table></figure></p>
<p>注意：Thread的异常处理，需要在run方法中，使用try/catch来处理，另外有方法setUncaughtExceptionHandler来处理 uncheck exception</p>
<h4 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h4><p>推荐通过实现Runnable接口，而非继承Thread，从而避免单继承的局限性。</p>
<h4 id="Callable接口、Future"><a href="#Callable接口、Future" class="headerlink" title="Callable接口、Future"></a>Callable接口、Future</h4><p>Callable接口与Runnable接口相似，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，基本使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Future的两个方法</span></div><div class="line">future.isDone() <span class="comment">//return  true,false 无阻塞 </span></div><div class="line">future.get() <span class="comment">//  return 返回值，阻塞直到该线程运行结束</span></div><div class="line"></div><div class="line"><span class="comment">// 方法1：FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">				<span class="comment">// 返回码</span></div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(callable);</div><div class="line">		<span class="keyword">new</span> Thread(future).start();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(<span class="number">5000</span>);<span class="comment">// 模拟业务逻辑</span></div><div class="line">			System.out.println(future.get());</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"><span class="comment">// 方法2：通过ExecutorService（继承Executor，管理Thread，简化并发编程）的submit方法执行Callable</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ExecutorService threadPool = Executors.newCachedThreadPool();</div><div class="line">		Future&lt;Integer&gt; future = threadPool.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">				<span class="comment">// 返回码</span></div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(<span class="number">5000</span>);<span class="comment">// 模拟业务逻辑</span></div><div class="line">			System.out.println(future.get());</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="锁与同步"><a href="#锁与同步" class="headerlink" title="锁与同步"></a>锁与同步</h3><p>锁与同步方法是常用于保证Java操作原子性，使用锁，可以保证同一时间只有一个线程拿到锁，因此保证了同一时间只有一个线程能够执行申请锁和释放锁之间的代码。<br>Java Lock 实现方式：<a href="http://aducode.github.io/posts/2015-10-30/java_concurrent03.html" title="Lock详解" target="_blank" rel="external">Lock详解 - Raven’s Blog</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用lock来实现synchronized的效果，主要区别:使用synchronized修饰的方法或代码块，在执行完之后会自动释放锁；而Lock则需要手动释放。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> Outputter1 output = <span class="keyword">new</span> Outputter1();</div><div class="line">		<span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				output.output(<span class="string">"zhangsan"</span>);</div><div class="line">			&#125;;</div><div class="line">		&#125;.start();</div><div class="line">		<span class="keyword">new</span> Thread() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				output.output(<span class="string">"lisi"</span>);</div><div class="line">			&#125;;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outputter1</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 锁对象</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		lock.lock();<span class="comment">// 得到锁</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//互斥区</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; name.length(); i++) &#123;</div><div class="line">				System.out.print(name.charAt(i));</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			<span class="comment">//为了保证能被释放，因此需要放在finall</span></div><div class="line">			lock.unlock();<span class="comment">// 释放锁</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相对synchronized，锁机制更具灵活性，例如，使用读写锁（ReadWriteLock - 读与写互斥、写与写互斥、但读与读不互斥，以此提高性能）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读写锁</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> Data data = <span class="keyword">new</span> Data();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">						data.set(<span class="keyword">new</span> Random().nextInt(<span class="number">30</span>));</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;).start();</div><div class="line">		&#125;		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">						data.get();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> data;<span class="comment">// 共享数据</span></div><div class="line">	<span class="keyword">private</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">		rwl.writeLock().lock();<span class="comment">// 取到写锁</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"准备写入数据"</span>);</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">20</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">this</span>.data = data;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"写入"</span> + <span class="keyword">this</span>.data);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			rwl.writeLock().unlock();<span class="comment">// 释放写锁</span></div><div class="line">		&#125;</div><div class="line">	&#125;	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">		rwl.readLock().lock();<span class="comment">// 取到读锁</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"准备读取数据"</span>);</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">20</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"读取"</span> + <span class="keyword">this</span>.data);</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			rwl.readLock().unlock();<span class="comment">// 释放读锁</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CAS（compare-and-swap）"><a href="#CAS（compare-and-swap）" class="headerlink" title="CAS（compare and swap）"></a>CAS（compare and swap）</h3><p>Java并发包（java.util.concurrent.atomic）下，提供了原子操作类来实现原子性操作方法，从而保证原子性，而其本质是利用了CPU级别的CAS指令。（下面以AtomicInteger为例说明）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//源码中的两个有代表性的方法</span></div><div class="line"><span class="comment">//相当于原子性的++i</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> current = get();</div><div class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line">            <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//相当于原子性的--i</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> current = get();</div><div class="line">        <span class="keyword">int</span> next = current - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</div><div class="line">            <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//两种方法都没有使用阻塞式方法来保证原子性，而是通过了CAS指令实现</span></div></pre></td></tr></table></figure></p>
<ul>
<li>CAS是线代CPU广泛支持的一种对内存中共享数据进行操作的特殊指令。</li>
<li>CAS操作过程简述：CPU将内存中将要被更改的数据与期望值做对比，当这两个值相等时，CPU才会将内存的数值替换为新的值，否则不操作。</li>
<li>缺点分析：虽然CAS可以实现非阻塞式的原子性操作，但会产生ABA问题（什么是ABA问题？ 例子：线程1准备用CAS将变量的值从A替换成B，但在之前，线程2将变量的值从A替换成C，又从C替换成A，然后问题来了，按照原子性理论，此时线程1不应该执行A-&gt;B才对，但线程1执行CAS时候发现变量的值仍然为A，CAS成功，这样的结果，可能会潜在未知的问题）。</li>
<li>更详细的ABA问题见：<a href="http://www.cnblogs.com/549294286/p/3766717.html" title="Java CAS 与 ABA 问题" target="_blank" rel="external">Java CAS 与 ABA 问题</a></li>
</ul>
<h3 id="待扩展的知识点"><a href="#待扩展的知识点" class="headerlink" title="待扩展的知识点"></a>待扩展的知识点</h3><p>探究线程知识过程中，发现其与许多其他知识或多或少有着联系，仍需继续努力，嗯，加油！<br>待扩展：Java类加载机制、JVM内存模型、Java异常分析</p>
]]></content>
      
        
        <tags>
            
            <tag> Java进阶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java自动装、拆箱解析]]></title>
      <url>http://yoursite.com/2016/10/09/Java%E8%87%AA%E5%8A%A8%E8%A3%85%E3%80%81%E6%8B%86%E7%AE%B1%E8%AE%A4%E7%9F%A5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 之前虽然略有听闻自动装箱、自动拆箱，却一直不清楚装箱、拆箱到底是什么，直到今天看到一段有趣的小程序，决定研究一番装箱与拆箱。<a id="more"></a><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">         Integer i1 = <span class="number">30</span>;</div><div class="line">         Integer i2 = <span class="number">30</span>;</div><div class="line">         Integer i3 = <span class="number">128</span>;</div><div class="line">         Integer i4 = <span class="number">128</span>;</div><div class="line">         System.out.println(i1 == i2);</div><div class="line">         System.out.println(i3 == i4);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//输出结果：</span></div><div class="line">     <span class="comment">//true</span></div><div class="line">     <span class="comment">//false</span></div><div class="line">     <span class="comment">//why? 抱着疑问，开始探索！</span></div></pre></td></tr></table></figure></p>
<ul>
<li>基本概念<ul>
<li>自动装箱：八种基本数据类型在某些条件下使用时候，会自动变为对应的包装类型。（上面的代码，就是自动装箱的一种）</li>
<li>自动拆箱：八种包装类型在某些条件下使用时候，会自动变成对应的基本数据类型。</li>
</ul>
</li>
<li>简单来说，代码表示是这样的<ul>
<li>自动装箱：Integer i = 10;(int -&gt; Integer) </li>
<li>自动拆箱：int n = i;(Integer -&gt; int)</li>
</ul>
</li>
</ul>
<p>附：八种基本数据类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">占用空间(Byte)</th>
<th style="text-align:center">表示范围</th>
<th style="text-align:center">包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">1/8</td>
<td style="text-align:center">true/false</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-128~127</td>
<td style="text-align:center">Character</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-2^15 ~ 2^15-1</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">-2^31 ~ 2^31-1</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-2^63 ~ 2^63-1</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">-3.403E38 ~ 3.403E38</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">-1.798E308 ~ 1.798E308</td>
<td style="text-align:center">Double</td>
</tr>
</tbody>
</table>
<h2 id="认识自动装箱"><a href="#认识自动装箱" class="headerlink" title="认识自动装箱"></a>认识自动装箱</h2><p> 回看看开头的代码，第一次输出true，很合乎情理，而第二次输出却是false，这就很让人疑惑了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">         Integer i1 = <span class="number">30</span>;</div><div class="line">         Integer i2 = <span class="number">30</span>;</div><div class="line">         Integer i3 = <span class="number">128</span>;</div><div class="line">         Integer i4 = <span class="number">128</span>;</div><div class="line">         System.out.println(i1 == i2);</div><div class="line">         System.out.println(i3 == i4);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//输出结果：</span></div><div class="line">     <span class="comment">//true</span></div><div class="line">     <span class="comment">//false</span></div><div class="line">     <span class="comment">//why? 抱着疑问，开始探索！</span></div></pre></td></tr></table></figure></p>
<p><strong>解析：</strong><br>当包装器类进行“==”比较时，内部会调用 Integer.valueOf方法进行自动装箱（int -&gt; Integer）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/**</span></div><div class="line">      * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</div><div class="line">      * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</div><div class="line">      * required, this method should generally be used in preference to</div><div class="line">      * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</div><div class="line">      * to yield significantly better space and time performance by</div><div class="line">      * caching frequently requested values.</div><div class="line">      *</div><div class="line">      * This method will always cache values in the range -128 to 127,</div><div class="line">      * inclusive, and may cache other values outside of this range.</div><div class="line">      *</div><div class="line">      * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</div><div class="line">      * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</div><div class="line">      * <span class="doctag">@since</span>  1.5</div><div class="line">      */</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">         <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">             <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p> 从源码中可见，Integer对象内部有IntegerCache类，可缓存（-128~127范围的数值），如果超过了，则会返回一个新的Integer类。由于“==”比较的是内存地址，因此，在“-128~127”数值范围内，比较的是同一个对象，得到true，而超过了该范围，则是返回自动装箱后的新对象，因此得到false。</p>
<p><strong>总结：</strong></p>
<ol>
<li>Integer、Short、Byte、Character、Long这几个包装类的valueOf方法的实现是类似的</li>
<li>Double、Float的valueOf方法的实现是类似的</li>
<li>Boolean的valueOf方法的实现是个三目运算，形如<code>return (b ? TRUE : FALSE);</code></li>
</ol>
<h2 id="认识自动拆箱"><a href="#认识自动拆箱" class="headerlink" title="认识自动拆箱"></a>认识自动拆箱</h2><p> 再看一段代码演示自动拆箱：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">         Integer i1 = <span class="number">30</span>;</div><div class="line">         <span class="keyword">int</span> i2 = <span class="number">30</span>;</div><div class="line">         <span class="keyword">int</span> i3 = <span class="number">128</span>;</div><div class="line">         Integer i4 = <span class="number">128</span>;</div><div class="line">         System.out.println(i1 == i2);</div><div class="line">         System.out.println(i3 == i4);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//输出结果：</span></div><div class="line">     <span class="comment">//true</span></div><div class="line">     <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><strong>解析：</strong><br>当与基本类型进行“==”比较时，包装器类会调用intValue方法进行自动拆箱（Integer -&gt; int）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">/**</span></div><div class="line">      * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as an</div><div class="line">      * &#123;<span class="doctag">@code</span> int&#125;.</div><div class="line">      */</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> value;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p> 从源码中可见，直接返回真实值，没有范围限制，因此两次输出均为true</p>
<h2 id="装箱与拆箱如何实现？"><a href="#装箱与拆箱如何实现？" class="headerlink" title="装箱与拆箱如何实现？"></a>装箱与拆箱如何实现？</h2><p> 看到这里，可能会有人疑问：“从哪里可用看出自动装箱调用了valueOf方法而自动拆箱则调用了intValue方法呢？”答案便是 - 通过反编译class文件，下面作简单演示：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyJava</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Integer i = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> i2 = i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 编译后，在控制台中使用 javap -c StudyJava 命令可得到：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Compiled from "StudyJava.java"</div><div class="line">public class StudyJava &#123;</div><div class="line">  public StudyJava();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: iconst_1</div><div class="line">       1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</div><div class="line">       4: astore_1</div><div class="line">       5: aload_1</div><div class="line">       6: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</div><div class="line">       9: istore_2</div><div class="line">      10: return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 从反编译得到的字节码中不难看出，装箱（int -&gt; Integer）时候的确调用了Integer.valueOf方法；拆箱时则调用Integer.intValue方法</p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><ul>
<li><p>Double、Float的valueOf方法的实现与Integer、Short、Byte、Character、Long这几个类的实现方法有区别。<br><strong>原因：</strong>在一定范围内，整数数值是有限的，而对于浮点数，则不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns a &#123;<span class="doctag">@code</span> Double&#125; instance representing the specified</div><div class="line">     * &#123;<span class="doctag">@code</span> double&#125; value.</div><div class="line">     * If a new &#123;<span class="doctag">@code</span> Double&#125; instance is not required, this method</div><div class="line">     * should generally be used in preference to the constructor</div><div class="line">     * &#123;<span class="doctag">@link</span> #Double(double)&#125;, as this method is likely to yield</div><div class="line">     * significantly better space and time performance by caching</div><div class="line">     * frequently requested values.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>  d a double value.</div><div class="line">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Double&#125; instance representing &#123;<span class="doctag">@code</span> d&#125;.</div><div class="line">     * <span class="doctag">@since</span>  1.5</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</div><div class="line">        <span class="comment">//并没有缓存，直接返回一个新的实例化对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>明白源码中的实现后，相信大家对下面代码输出结果也都理解了吧~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyJava</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Double i1 = <span class="number">100.0</span>;</div><div class="line">        Double i2 = <span class="number">100.0</span>;</div><div class="line">        Double i3 = <span class="number">200.0</span>;</div><div class="line">        Double i4 = <span class="number">200.0</span>;</div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出结果</span></div><div class="line"><span class="comment">//false</span></div><div class="line"><span class="comment">//fasle</span></div></pre></td></tr></table></figure>
</li>
<li><p>接下来再提一下Boolean类，装箱valueOf实现代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns a &#123;<span class="doctag">@code</span> Boolean&#125; instance representing the specified</div><div class="line">     * &#123;<span class="doctag">@code</span> boolean&#125; value.  If the specified &#123;<span class="doctag">@code</span> boolean&#125; value</div><div class="line">     * is &#123;<span class="doctag">@code</span> true&#125;, this method returns &#123;<span class="doctag">@code</span> Boolean.TRUE&#125;;</div><div class="line">     * if it is &#123;<span class="doctag">@code</span> false&#125;, this method returns &#123;<span class="doctag">@code</span> Boolean.FALSE&#125;.</div><div class="line">     * If a new &#123;<span class="doctag">@code</span> Boolean&#125; instance is not required, this method</div><div class="line">     * should generally be used in preference to the constructor</div><div class="line">     * &#123;<span class="doctag">@link</span> #Boolean(boolean)&#125;, as this method is likely to yield</div><div class="line">     * significantly better space and time performance.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>  b a boolean value.</div><div class="line">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Boolean&#125; instance representing &#123;<span class="doctag">@code</span> b&#125;.</div><div class="line">     * <span class="doctag">@since</span>  1.4</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</div><div class="line">        <span class="comment">//TRUE、FALSE为两个内部定义的静态成员，这里直接返回两者其一</span></div><div class="line">        <span class="comment">// public static final Boolean TRUE = new Boolean(true);</span></div><div class="line">        <span class="comment">// public static final Boolean FALSE = new Boolean(false);</span></div><div class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>既然返回的是内部定义静态成员，只要值相同，那么就是同一个对象，因此下面代码就很好理解啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyJava</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Boolean i1 = <span class="keyword">false</span>;</div><div class="line">        Boolean i2 = <span class="keyword">false</span>;</div><div class="line">        Boolean i3 = <span class="keyword">true</span>;</div><div class="line">        Boolean i4 = <span class="keyword">true</span>;</div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出结果</span></div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
<li><p>稍微复杂一点呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyJava</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Integer i1 = <span class="number">1</span>;</div><div class="line">		Integer i2 = <span class="number">2</span>;</div><div class="line">		Integer i3 = <span class="number">200</span>;</div><div class="line">		<span class="keyword">int</span> i4 = i1 + <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> i5 = <span class="number">200</span>;</div><div class="line">		Integer i6 = <span class="number">200</span>;</div><div class="line">		Long l1 = <span class="number">3L</span>;</div><div class="line">		Long l2 = <span class="number">2L</span>;</div><div class="line">		System.out.println(i4 == i2); - <span class="keyword">true</span></div><div class="line">		System.out.println(i2.equals(i4)); - <span class="keyword">true</span></div><div class="line">		System.out.println(i3 == i5); - <span class="keyword">true</span></div><div class="line">		System.out.println(i3.equals(i5)); - <span class="keyword">true</span></div><div class="line">		System.out.println(i3 == i6); - <span class="keyword">false</span></div><div class="line">		System.out.println(i3.equals(i6)); - <span class="keyword">true</span></div><div class="line">		<span class="comment">// System.out.println(l2==i2);//该行为错误代码，无法通过编译，类型不同</span></div><div class="line">		System.out.println(l1 == (i1 + i2)); - <span class="keyword">true</span><span class="comment">//可见其中进行了一些操作，使得两者可以比较</span></div><div class="line">		System.out.println(l2.equals(i1 + i2)); - <span class="keyword">false</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"><span class="comment">//输出结果：</span></div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="comment">//false</span></div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="comment">//true</span></div><div class="line"><span class="comment">//false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>其中值得注意的，是最后两行代码：<br>“l1 == (i1 + i2)”其中包含了算术运算，会触发自动拆箱（算术运算需要自动拆箱，各自调用intValue方法得到基本类型），再进行自动装箱，最终他们进行了数值比较，因此可以正常编译；<br>而“l2.equals(i1 + i2)”则是，先触发“i1 + i2”的自动拆箱（算术运算需要自动拆箱，各自调用intValue方法得到基本类型），算术运算得到数值后，再进行数值对应类型的自动装箱（valueOf），得到Integer实例对象，最后再进行equals比较。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>弄懂原理以及自动装、拆箱的时机，外加一点心细，就能较好地掌握本知识点啦，建议大家多动手实验，亲自验证一番，肯定有更多的收获的。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[启发式搜索 - 有趣而神奇的 A* 算法]]></title>
      <url>http://yoursite.com/2016/09/27/A%E6%98%9F%E5%90%AF%E5%8F%91%E5%BC%8F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在课堂上听老师讲了一个人工智能的基础小算法，感觉神奇而有趣，便自行研究一下。研究了几个小时，总算实现了。想写一篇博文来记录一下今天的学习经历，那么，就请有兴趣的各位跟我一起从零实现一个简单的A星寻路算法啦。<a id="more"></a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>首先，需要有个基本概念：A*搜寻算法俗称“A星算法”。这是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。（启发式搜索）</li>
</ul>
<h2 id="几个要素"><a href="#几个要素" class="headerlink" title="几个要素"></a>几个要素</h2><ul>
<li>是否相通的标记（标记有许多种方式，例如：0为通畅、1为障碍；或者把两两结点的线路保存下来，再去查该线路是否存在）</li>
<li>一个父亲结点指针（处理结点时候，需要知道该结点的父节点）</li>
<li>OPEN 表（待检查的点，认为当前点为父亲结点，父亲结点也要保存，）</li>
<li>CLOSE 表（不再检查的点）</li>
<li>一条公式：F = H + G<br>F 为到终点的总耗费<br>H 为网格上当前方格移动到终点的预估耗费（预估算法有很多种，例如：“曼哈顿法”：H = |行数| + |列数|、另外也可利用直线距离…）；<br>G 为父亲结点移动到当前结点的预估移动耗费；</li>
<li><p>现在，再来举个栗子，下面的步骤解析也会与之相结合：</p>
<p> <img src="http://odzvmv4ab.bkt.clouddn.com/A%E6%98%9F%E7%AE%97%E6%B3%95%E5%9C%B0%E5%9B%BE.png" alt="A*小栗子"></p>
<p>   简单解释：</p>
<pre><code>- 图中有 A、B、C、D、E、F、G、H 8个结点（ A 为起点、E 为终点）
- 括号为当前结点到终点的预估值（由于预估算法的选择有许多，使用时需要根据实际情况选择，而我们现在优先学习A星算法的思路，因此这里直接给出预估值 - 即 H 值）
- 结点间的连线为相同直线，上面的数字代表线路的移动耗费值（即 G 值）
- 任务：利用A星算法计算出路线
</code></pre></li>
</ul>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol>
<li>设起点 A ，将 A 加入 OPEN 表</li>
<li>寻找相邻可达点，计算出其 F 值，并加入 OPEN 表；若相邻点已经在 Open 表中，则判断其是否需要更新 F 值；若相邻点已经在 Close 表中，则跳过该点</li>
<li>将原父亲结点（A 结点）从 OPEN 表中删除，把它加入到 CLOSE 表中</li>
<li>从 OPEN 表中选择一个 F值最小的，然后将它作为父亲结点，继续处理其相邻结点</li>
<li>只要 Open 表不为空，则循环执行上述2、3、4步骤，发现相邻点是终点，则跳出循环。</li>
<li>当 Open 表为空，还没有找到终点，则说明起点不可达到终点</li>
</ol>
<h2 id="Just-show-me-the-code-！"><a href="#Just-show-me-the-code-！" class="headerlink" title="Just show me the code ！"></a>Just show me the code ！</h2><p>讲了那么多，理论知识总该要实践才行，建议大家先参考伪代码，理解好算法思路，自行尝试实现一番，再去看我那些半桶水的实现代码，一定会有更多收获的。</p>
<p>一段核心思路伪代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(OPEN!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">    从OPEN表中取f(n)最小的节点n;</div><div class="line">    <span class="keyword">if</span>(n节点==目标节点)</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">for</span>(当前节点n的每个子节点X)</div><div class="line">    &#123;</div><div class="line">        计算f(X);</div><div class="line">        <span class="keyword">if</span>(XinOPEN)</div><div class="line">            <span class="keyword">if</span>(新的f(X)&lt;OPEN中的f(X))</div><div class="line">            &#123;</div><div class="line">                把n设置为X的父亲;</div><div class="line">                更新OPEN表中的f(n);</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">if</span>(XinCLOSE)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(Xnotinboth)</div><div class="line">        &#123;</div><div class="line">            把n设置为X的父亲;</div><div class="line">            求f(X);</div><div class="line">            并将X插入OPEN表中;<span class="comment">//还没有排序</span></div><div class="line">        &#125;</div><div class="line">    &#125;<span class="comment">//endfor</span></div><div class="line">    将n节点插入CLOSE表中;</div><div class="line">    按照f(n)将OPEN表中的节点排序;<span class="comment">//实际上是比较OPEN表内节点f的大小，从最小路径的节点向下进行。</span></div><div class="line">&#125;<span class="comment">//endwhile(OPEN!=NULL)</span></div></pre></td></tr></table></figure></p>
<p>我的 Java 实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.goo.astart;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *路径实体类</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> Goo</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Road</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> String name;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> length;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Road</span><span class="params">(String name, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.length = length;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.goo.astart;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 结点实体类</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> Goo</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeStruct</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NodeStruct</span><span class="params">(String nodeName, <span class="keyword">int</span> estimate)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.nodeName = nodeName;</div><div class="line">		<span class="keyword">this</span>.estimate = estimate;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 结点名称</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> String nodeName;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 父亲结点</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> NodeStruct fatherNode = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 总耗费</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> weight = <span class="number">0</span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当前结点到终点的预估耗费</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> estimate = <span class="number">0</span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 父亲结点到当前结点的实际耗费</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> practical = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Main.java</span></div><div class="line"><span class="keyword">package</span> com.goo.astart;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> javax.management.openmbean.OpenDataException;</div><div class="line"><span class="keyword">import</span> javax.xml.soap.Node;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 含有主方法的主逻辑类</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> Goo</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;NodeStruct&gt; dataList = <span class="keyword">new</span> ArrayList&lt;NodeStruct&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Road&gt; roadList = <span class="keyword">new</span> ArrayList&lt;Road&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;NodeStruct&gt; openList = <span class="keyword">new</span> ArrayList&lt;NodeStruct&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;NodeStruct&gt; closeList = <span class="keyword">new</span> ArrayList&lt;NodeStruct&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> NodeStruct startNode;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> NodeStruct endNode;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASFOUND = <span class="number">10000</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOTFOUND = <span class="number">20000</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stepCount = <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		loadData();</div><div class="line">		<span class="comment">// 1、将起点加入Open表</span></div><div class="line">		addToOpenList(startNode);</div><div class="line">		<span class="comment">// 2、搜索相邻路径？</span></div><div class="line">		<span class="keyword">if</span> (search() == HASFOUND) &#123;</div><div class="line">			System.out.println(<span class="string">"路径搜索完成，成功找到最短路径"</span>);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			System.out.println(<span class="string">"路径搜索完成，没有可达路径"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * A星核心算法</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// Open表不为空</span></div><div class="line">		<span class="keyword">while</span> (openList.size() != <span class="number">0</span>) &#123;</div><div class="line">			<span class="comment">// 按照总耗费从小到大排序</span></div><div class="line">			Collections.sort(openList, <span class="keyword">new</span> Comparator&lt;NodeStruct&gt;() &#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(NodeStruct node1, NodeStruct node2)</span> </span>&#123;</div><div class="line">					<span class="keyword">return</span> node1.weight - node2.weight;</div><div class="line">				&#125;;</div><div class="line">			&#125;);</div><div class="line">			<span class="comment">// 取最小结点作为父亲结点</span></div><div class="line">			NodeStruct fatherNode = openList.get(<span class="number">0</span>);</div><div class="line">			stepCount++;</div><div class="line">			System.out.println(<span class="string">"步骤"</span> + stepCount + <span class="string">":"</span> + fatherNode.nodeName</div><div class="line">					+ <span class="string">" - 结点F值："</span> + fatherNode.weight);</div><div class="line">			<span class="comment">// 结点已找到</span></div><div class="line">			<span class="keyword">if</span> (fatherNode.equals(endNode)) &#123;</div><div class="line">				<span class="keyword">return</span> HASFOUND;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 寻找相邻路径</span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataList.size(); i++) &#123;</div><div class="line">				NodeStruct neighNode = dataList.get(i);</div><div class="line">				String roadName = neighNode.nodeName + fatherNode.nodeName;</div><div class="line">				String roadNameRev = fatherNode.nodeName + neighNode.nodeName;</div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; roadList.size(); j++) &#123;</div><div class="line">					Road tempRoad = roadList.get(j);</div><div class="line">					<span class="comment">// 找到相邻点</span></div><div class="line">					<span class="keyword">if</span> (roadName.equals(tempRoad.name)</div><div class="line">							|| roadNameRev.equals(tempRoad.name)) &#123;</div><div class="line">						<span class="comment">// 如果在Close表中，忽略</span></div><div class="line">						<span class="keyword">if</span> (closeList.contains(neighNode)) &#123;</div><div class="line">							<span class="keyword">continue</span>;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (openList.contains(neighNode)) &#123;</div><div class="line">							<span class="comment">// 如果在Open表中</span></div><div class="line">							<span class="comment">// 如果父亲结点到该结点耗费值更小，则更新耗费值</span></div><div class="line">							<span class="keyword">if</span> (tempRoad.length + neighNode.estimate &lt; neighNode.weight) &#123;</div><div class="line">								neighNode.weight = tempRoad.length</div><div class="line">										+ neighNode.estimate;</div><div class="line">							&#125;</div><div class="line">						&#125; <span class="keyword">else</span> &#123;</div><div class="line">							<span class="comment">// 两个表都没有（空白点）</span></div><div class="line">							<span class="comment">// 计算该点总耗费</span></div><div class="line">							neighNode.weight = neighNode.estimate</div><div class="line">									+ tempRoad.length;</div><div class="line">							<span class="comment">// 成功搜索路径，认为是相邻点，加入到Open表</span></div><div class="line">							addToOpenList(neighNode);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 最后将父结点移除Open表，放入Close表</span></div><div class="line">			removeFromOpen(fatherNode);</div><div class="line">			addToCloseList(fatherNode);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> NOTFOUND;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 加载数据</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</div><div class="line">		startNode = <span class="keyword">new</span> NodeStruct(<span class="string">"A"</span>, <span class="number">15</span>);</div><div class="line">		startNode.weight = <span class="number">15</span>;</div><div class="line">		endNode = <span class="keyword">new</span> NodeStruct(<span class="string">"E"</span>, <span class="number">0</span>);</div><div class="line">		dataList.add(startNode);</div><div class="line">		dataList.add(endNode);</div><div class="line">		dataList.add(<span class="keyword">new</span> NodeStruct(<span class="string">"B"</span>, <span class="number">14</span>));</div><div class="line">		dataList.add(<span class="keyword">new</span> NodeStruct(<span class="string">"C"</span>, <span class="number">10</span>));</div><div class="line">		dataList.add(<span class="keyword">new</span> NodeStruct(<span class="string">"D"</span>, <span class="number">2</span>));</div><div class="line">		dataList.add(<span class="keyword">new</span> NodeStruct(<span class="string">"F"</span>, <span class="number">5</span>));</div><div class="line">		dataList.add(<span class="keyword">new</span> NodeStruct(<span class="string">"G"</span>, <span class="number">9</span>));</div><div class="line">		dataList.add(<span class="keyword">new</span> NodeStruct(<span class="string">"H"</span>, <span class="number">11</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"AB"</span>, <span class="number">3</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"AH"</span>, <span class="number">4</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"BH"</span>, <span class="number">5</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"CG"</span>, <span class="number">3</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"CD"</span>, <span class="number">8</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"CB"</span>, <span class="number">4</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"DG"</span>, <span class="number">8</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"DF"</span>, <span class="number">3</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"DE"</span>, <span class="number">2</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"FG"</span>, <span class="number">4</span>));</div><div class="line">		roadList.add(<span class="keyword">new</span> Road(<span class="string">"GH"</span>, <span class="number">2</span>));</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 添加到 Open 表</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> node</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToOpenList</span><span class="params">(NodeStruct node)</span> </span>&#123;</div><div class="line">		openList.add(node);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 添加到 Close 表</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> node</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToCloseList</span><span class="params">(NodeStruct node)</span> </span>&#123;</div><div class="line">		closeList.add(node);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 从 Open 表移除</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> node</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeFromOpen</span><span class="params">(NodeStruct node)</span> </span>&#123;</div><div class="line">		openList.remove(node);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 从 Close 表移除</div><div class="line">	 * </div><div class="line">	 * <span class="doctag">@param</span> node</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeFromClose</span><span class="params">(NodeStruct node)</span> </span>&#123;</div><div class="line">		closeList.remove(node);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相信大家动手实现后，就会对A*算法有个基本的认识啦，以上代码通过了几个简单的样例，但不排除会隐藏着奇怪的 Bug 噢，或者是一段有待改进的代码，欢迎大家指点指点。</p>
]]></content>
      
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[拆轮子笔记 - OkHttp]]></title>
      <url>http://yoursite.com/2016/09/24/%E6%8B%86%E8%BD%AE%E5%AD%90%E7%AC%94%E8%AE%B0%20-%20OkHttp/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用了那么久的OkHttp，解决了不少的联网问题。对于热门的好轮子，总不能一直停留在会用这个层面上吧，是时候动手拆拆轮子，学习一下其中的原理。本文主要记录笔者通过各种网络学习资源及<a href="&quot;https://github.com/square/okhttp&quot;">OkHttp源码</a>的过程，希望通过自身学习研究的过程，给其他同学提供一些参考与帮助，如有不足，恳请指教。<a id="more"></a></p>
<ul>
<li>本文记录基于 OkHttp 3.4.1 源码的学习分析过程。</li>
<li>笔者水平有限，内容可能基于学习资源，当然也会有个人的一些见解加入其中，仅作个人笔记用途，同时也试图探索学习如何入手拆轮子的好方法推荐给各位，如有侵权，马上删除。<h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2></li>
<li><a href="&quot;http://blog.piasy.com/2016/07/11/Understand-OkHttp/&quot;">Piasy - 拆轮子系列：拆 OkHttp</a></li>
<li><a href="&quot;http://www.jianshu.com/p/b68b928d7213&quot;">简书 - 拆轮子系列之OKHttp-上层架构</a></li>
<li><a href="&quot;http://www.jianshu.com/p/aad5aacd79bf&quot;">简书 - OkHttp3源码分析[综述]</a></li>
<li><a href="&quot;http://frodoking.github.io/2015/03/12/android-okhttp/&quot;">Frodo - OkHttp源码解析</a></li>
<li><a href="&quot;http://frodoking.github.io/2015/06/29/android-okhttp-connectionpool-http1-x-http2-x/&quot;">Frodo - OKHttp源码解析-ConnectionPool对Connection重用机制&amp;Http/Https/SPDY协议选择</a></li>
</ul>
<h2 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h2><h3 id="跟随Piasy-拆轮子（学习资源-第一篇）"><a href="#跟随Piasy-拆轮子（学习资源-第一篇）" class="headerlink" title="跟随Piasy 拆轮子（学习资源 - 第一篇）"></a><a href="&quot;http://blog.piasy.com/2016/07/11/Understand-OkHttp/&quot;">跟随Piasy 拆轮子（学习资源 - 第一篇）</a></h3><h4 id="阅读心得："><a href="#阅读心得：" class="headerlink" title="阅读心得："></a>阅读心得：</h4><ol>
<li>从最实际的基本使用方法进行拓展、步步深入分析</li>
<li>没有过多深入到细节进行解析，进阶知识需要继续钻研</li>
<li>是带领大家入手拆轮子的好文章。（强烈建议各位边阅读边看源码，更加有助于理解其中的实现方式！）</li>
<li>再次感谢 Piasy 大神</li>
</ol>
<h4 id="文章知识点："><a href="#文章知识点：" class="headerlink" title="文章知识点："></a>文章知识点：</h4><ol>
<li>关注 OkHttp 整体工作流程，结合源码解析了“创建 OkHttpClient 对象”、“发起 HTTP 请求”、“同步网络请求”、“异步网络请求”等使用方法</li>
<li>详解了其中应用的核心设计模式：责任链模式</li>
<li>分析了 OkHttp 如何“建立连接”、“发送和接收数据”、“发起异步网络请求”、“获取返回数据”、“Http缓存”</li>
</ol>
<h4 id="学习笔记："><a href="#学习笔记：" class="headerlink" title="学习笔记："></a>学习笔记：</h4><p>  这里贴出笔者阅读文章时，看源码的顺序与结合理解的注解。</p>
<ol>
<li>从 OkHttp 创建对象使用方法入手<br><code>OkHttpClient client = new OkHttpClient();</code></li>
<li><p>进入构造方法，发现内部会创建 Builder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造方法中已初始化 Builder</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>建造者模式？进入 OkHttpClient.Builder 构造方法一探究竟，直接创建的 OkHttpClient 会默认使用基本配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</div><div class="line">  dispatcher = <span class="keyword">new</span> Dispatcher();</div><div class="line">  protocols = DEFAULT_PROTOCOLS;</div><div class="line">  connectionSpecs = DEFAULT_CONNECTION_SPECS;</div><div class="line">  proxySelector = ProxySelector.getDefault();</div><div class="line">  cookieJar = CookieJar.NO_COOKIES;</div><div class="line">  socketFactory = SocketFactory.getDefault();</div><div class="line">  hostnameVerifier = OkHostnameVerifier.INSTANCE;</div><div class="line">  certificatePinner = CertificatePinner.DEFAULT;</div><div class="line">  proxyAuthenticator = Authenticator.NONE;</div><div class="line">  authenticator = Authenticator.NONE;</div><div class="line">  connectionPool = <span class="keyword">new</span> ConnectionPool();</div><div class="line">  dns = Dns.SYSTEM;</div><div class="line">  followSslRedirects = <span class="keyword">true</span>;</div><div class="line">  followRedirects = <span class="keyword">true</span>;</div><div class="line">  retryOnConnectionFailure = <span class="keyword">true</span>;</div><div class="line">  connectTimeout = <span class="number">10_000</span>;</div><div class="line">  readTimeout = <span class="number">10_000</span>;</div><div class="line">  writeTimeout = <span class="number">10_000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>接下来，看看发起 Http 请求 OkHttp 用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">//构造请求体</span></div><div class="line">  Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">      .url(url)</div><div class="line">      .build();	</div><div class="line">  <span class="comment">//发起请求核心代码</span></div><div class="line">  Response response = client.newCall(request).execute();</div><div class="line">  <span class="keyword">return</span> response.body().string();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法解析：client.newCall(request) - 根据请求创建新的 Call 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">  <span class="comment">//实际构造并返回 RealCall 对象</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法解析：client.newCall(request).execute() - 执行请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">      executed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      client.dispatcher().executed(<span class="keyword">this</span>);</div><div class="line">      Response result = getResponseWithInterceptorChain();</div><div class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>上述代码主要做了4件事：</p>
<ol>
<li>判断是否被执行 - 说明每个call只能被执行一次；另：可通过clone方法得到一个完全一样的Call（该方法是 Object类的方法）</li>
<li><p>利用client.dispatcher().executed(this)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dispatcher()方法返回 dispatcher ，异步http请求策略(内部使用 ExecutorService 实现)</span></div><div class="line"><span class="function"><span class="keyword">public</span> Dispatcher <span class="title">dispatcher</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dispatcher;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 getResponseWithInterceptorChain() 获取Http返回结果(InterceptorChain - 拦截链? 一系列拦截操作待分析)  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法解析：构建一个完整的 interceptors List，最后利用该 list 构建 Interceptor.Chain</span></div><div class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	<span class="comment">//1.添加 client 携带的所有 interceptors （配置 OkHttpClient 时候用户设置的 interceptors ）</span></div><div class="line">    interceptors.addAll(client.interceptors());</div><div class="line">	<span class="comment">//2.添加 retryAndFollowUpInterceptor （负责失败重试以及重定性）</span></div><div class="line">    interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">	<span class="comment">//3.添加由 client.cookieJar() 构建的 BridgeInterceptor（负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的相应转换为用户友好响应 - 即客户端与服务器端沟通的桥梁）</span></div><div class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">	<span class="comment">//4.添加由 client.internalCache() 构建的 CacheInterceptor （负责读取缓存直接返回、更新缓存）</span></div><div class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">	<span class="comment">//5.添加由 client 构建的 ConnectInterceptor （负责与服务器建立连接）</span></div><div class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">	<span class="comment">//如果 forWebSocket 则添加 client 携带的所有 networkInterceptors（配置OkHttpClient 时候用户设置的 networkInterceptors）</span></div><div class="line">    <span class="keyword">if</span> (!retryAndFollowUpInterceptor.isForWebSocket()) &#123;</div><div class="line">      interceptors.addAll(client.networkInterceptors());</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//添加 CallServerInterceptor （负责向服务器发送给请求数据、从服务器读取响应数据）</span></div><div class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(</div><div class="line">        retryAndFollowUpInterceptor.isForWebSocket()));</div><div class="line">	<span class="comment">//构建 Interceptor.Chain ，最后调用 chain.proceed(originalRequest)，第7点有解析</span></div><div class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">        interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>“责任链模式”科普（百度百科）</strong>：在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</li>
<li><strong>“责任链模式”科普（维基百科）</strong>：它包含了一些命令对象和一系列的处理对象，每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。</li>
<li><strong>总结</strong>：拦截链中，每个Interceptor都可处理 Request，返回 Response。运行时，顺着拦截链，让每个Interceptor 自行决定是否处理以及怎么处理（不处理则交给下一个Interceptor ），这样，可将处理网络请求从 RealCall 类中剥离，简化了各自责任与逻辑</li>
<li><strong>另</strong>：责任链模式 在 Android 有着许多典型应用，例：view的点击事件分发（Android源码设计模式一书中有提及）</li>
</ul>
</li>
<li>dispatcher 如果try{}没有抛出异常，并且 result != null（则不执行return，下面的finally才执行），最后还会通知 dispatcher 操作完成</li>
</ol>
</li>
<li><p>所以拦截链是如何工作的？ 方法解析 - chain.proceed(originalRequest)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpStream httpStream,</span></span></div><div class="line">      Connection connection) <span class="keyword">throws</span> IOException &#123;</div><div class="line">	<span class="comment">//首先需要各种判错</span></div><div class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">    calls++;</div><div class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpStream != <span class="keyword">null</span> &amp;&amp; !sameConnection(request.url())) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</div><div class="line">          + <span class="string">" must retain the same host and port"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpStream != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</div><div class="line">          + <span class="string">" must call proceed() exactly once"</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//然后再调用拦截链中的拦截器，最终得到 response</span></div><div class="line">    <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">        interceptors, streamAllocation, httpStream, connection, index + <span class="number">1</span>, request);</div><div class="line">    Interceptor interceptor = interceptors.get(index);</div><div class="line">    Response response = interceptor.intercept(next);</div><div class="line">	<span class="comment">//保证拦截链调用逻辑无误</span></div><div class="line">    <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></div><div class="line">    <span class="keyword">if</span> (httpStream != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</div><div class="line">          + <span class="string">" must call proceed() exactly once"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></div><div class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//返回 response</span></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>明白拦截链的整体工作流程后，那么 OkHttp 又如何与服务器进行实际通信的呢？这里需要分析 CallServerInterceptor 拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//负责与目标服务器连接、将请求传递给下一个拦截器</span></div><div class="line"><span class="comment">/** Opens a connection to the target server and proceeds to the next interceptor. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.client = client; </div><div class="line">  &#125;</div><div class="line">  <span class="comment">//核心方法</span></div><div class="line">  <span class="meta">@Override</span> </div><div class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">    Request request = realChain.request();</div><div class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></div><div class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</div><div class="line">	<span class="comment">//创建 HttpStream（接口） 对象这里的实现类是 Http2xStream、Http1xStream 分别对应 HTTP/1.1 和 HTTP2 版本</span></div><div class="line">	<span class="comment">//两者源码有点长，需要交给读者们自行深究，其中使用了 Okio 对 Socket 读写操作进行封装</span></div><div class="line">	<span class="comment">//Okio 可暂时认为是对 java.io、java.nio 进行封装，提供更高效的IO操作</span></div><div class="line">    HttpStream httpStream = streamAllocation.newStream(client, doExtensiveHealthChecks);</div><div class="line">    RealConnection connection = streamAllocation.connection();</div><div class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpStream, connection);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>另外，创建 HttpStream 对象还涉及 StreamAllocation、RealConnection 对象。<br>由于篇幅过长，这里不贴出源码，给出总体创建思路：找到可用的RealConnection，再利用 RealConnection 的输入输出（BufferedSource、BufferedSink）创建 HttpStream 对象。<br>9.接下来，来弄懂 OkHttp 如何发送、接收数据，需要分析拦截链中最后一个拦截器 CallServerInterceptor<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//拦截链中最后一个拦截器，负责向服务器发送给请求数据、从服务器读取响应数据</span></div><div class="line"><span class="comment">/** This is the last interceptor in the chain. It makes a network call to the server. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CallServerInterceptor</span><span class="params">(<span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">  &#125;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    HttpStream httpStream = ((RealInterceptorChain) chain).httpStream();</div><div class="line">    StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();</div><div class="line">    Request request = chain.request();</div><div class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class="line">	<span class="comment">//1、写入要发送的 Http Request Headers</span></div><div class="line">    httpStream.writeRequestHeaders(request);</div><div class="line">	<span class="comment">//2、如果请求方法允许，且 request.body 不为空，就加上一个body</span></div><div class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">//得到一个能传输 request body 的output stream</span></div><div class="line"> 	  Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength());</div><div class="line">      <span class="comment">//利用 Okio 将 requestBodyOut 写入，得到 bufferedRequestBody</span></div><div class="line">	  BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class="line">	  <span class="comment">//将 request body 写入到 bufferedRequestBody</span></div><div class="line">      request.body().writeTo(bufferedRequestBody);</div><div class="line">      bufferedRequestBody.close();</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//刷新 request 到 socket</span></div><div class="line">    httpStream.finishRequest();</div><div class="line">	<span class="comment">//构造新的 Response 对象</span></div><div class="line">    Response response = httpStream.readResponseHeaders()</div><div class="line">        .request(request)</div><div class="line">        .handshake(streamAllocation.connection().handshake())</div><div class="line">        .sentRequestAtMillis(sentRequestMillis)</div><div class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">        .build();</div><div class="line">    <span class="keyword">if</span> (!forWebSocket || response.code() != <span class="number">101</span>) &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(httpStream.openResponseBody(response))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</div><div class="line">        || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</div><div class="line">      streamAllocation.noNewStreams();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> code = response.code();</div><div class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</div><div class="line">          <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>核心工作基本由 HttpStream 完成（旧版本该类原名：HttpCodec ），利用了 Okio ，而 Okio 实际上还是使用了 Socket。</li>
<li>分析（来源于Piasy 拆OkHttp）：InterceptorChain 设计是一种分层思想，每层只关注自己的责任（单一责任原则），各层间通过约定的接口/协议进行合作，共同完成负责任务</li>
</ul>
<ol>
<li><p>初步学习了同步请求后，再从 OkHttp 异步网络请求用法中入手 OkHttp 异步网络请求的原理吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//核心方法 - enqueue</span></div><div class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(response.body().string());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>进一步研究 RealCall.enqueue 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//源码 - RealCall.enqueue</span></div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">  <span class="comment">//同步锁，如果已经执行会抛出异常</span></div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//关键调用 - Dispatcher.enqueue</span></div><div class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>继续深入，方法解析 - Dispatcher.enqueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//概述：同步方法，如果当前还能执行一个并发请求，则加入 runningAsyncCalls ，立即执行，否则加入 readyAsyncCalls 队列</span></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">    runningAsyncCalls.add(call);</div><div class="line">    executorService().execute(call);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    readyAsyncCalls.add(call);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>方法中涉及 AsyncCall 类 - RealCall 的一个内部类，它实现了 Runnable，因此可以提交到 ExecutorService 上执行</li>
<li>它在执行时会调用 getResponseWithInterceptorChain() 函数，并把结果通过 responseCallback 传递给上层使用者</li>
<li><strong>总结</strong>：同步请求跟异步请求的原理基本一致，最后都是调用 getResponseWithInterceptorChain() 函数，利用拦截链来实现的网络请求逻辑，只是实现方式不同，异步请求需要通过 ExecutorService 来调用getResponseWithInterceptorChain。</li>
</ul>
</li>
<li>原来同步、异步请求有着异曲同工之妙，探究完 OkHttp 请求发送，当然要继续探究下返回数据的获取啦。<ul>
<li>完成同步或是异步的请求后，我们就可以从 Response 对象中获取到相应数据了，而其中值得注意的，也是最重要的，便是 body 部分了，因为一般服务器返回的数据较大，必须通过数据流的方式来访问。</li>
<li>响应 body 被封装到 ResponseBody 类中，需要注意两点：<ul>
<li>每个 body 只能被消费一次，多次消费会出现异常</li>
<li>body 必须被关闭，否则会资源泄漏</li>
</ul>
</li>
</ul>
</li>
<li><p>最后再来看看 Http 缓存，需要探究 CacheInterceptor 拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在 ConnectInterceptor 之前添加的一个拦截器，也就是说，在建立连接之前需要看看是否有可用缓存，如果可以则直接返回缓存，否则就继续建立网络连接等操作</span></div><div class="line"><span class="comment">//代码较长、这里贴出核心部分(OkHttp 缓存处理逻辑)</span></div><div class="line"><span class="meta">@Override</span> </div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   ...</div><div class="line">	<span class="comment">//无可用缓存，放弃</span></div><div class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></div><div class="line">    &#125;</div><div class="line">	<span class="comment">//有可用缓存，但被强制要求联网，那交给下个拦截器，继续联网了</span></div><div class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></div><div class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</div><div class="line">          .request(chain.request())</div><div class="line">          .protocol(Protocol.HTTP_1_1)</div><div class="line">          .code(<span class="number">504</span>)</div><div class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</div><div class="line">          .body(EMPTY_BODY)</div><div class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</div><div class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//不需要联网，返回缓存</span></div><div class="line">    <span class="comment">// If we don't need the network, we're done.</span></div><div class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</div><div class="line">          .cacheResponse(stripBody(cacheResponse))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line">    Response networkResponse = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      networkResponse = chain.proceed(networkRequest);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">	  <span class="comment">//不管成不成功，都要记得关闭 cache body，避免内存泄漏</span></div><div class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></div><div class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</div><div class="line">        closeQuietly(cacheCandidate.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//如果有缓存响应，就进行相应的获取</span></div><div class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></div><div class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (validate(cacheResponse, networkResponse)) &#123;</div><div class="line">        Response response = cacheResponse.newBuilder()</div><div class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">            .cacheResponse(stripBody(cacheResponse))</div><div class="line">            .networkResponse(stripBody(networkResponse))</div><div class="line">            .build();</div><div class="line">        networkResponse.body().close();</div><div class="line">		<span class="comment">//更新缓存</span></div><div class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></div><div class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></div><div class="line">        cache.trackConditionalCacheHit();</div><div class="line">        cache.update(cacheResponse, response);</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        closeQuietly(cacheResponse.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>关于 OkHttp 内部的缓存实际实现？</p>
<ul>
<li>实现方式：主要涉及 HTTP 协议缓存细节的实现，而具体的缓存逻辑 OkHttp 内置封装了一个 Cache 类，它利用 DiskLruCache，用磁盘上的有限大小空间进行缓存，按照 LRU 算法进行缓存淘汰。（源码略长，需要各位自行查看钻研）</li>
<li>InternalCache（接口），我们可以实现该接口，使用我们自定义的缓存策略</li>
</ul>
</li>
</ol>
<h4 id="知识总结-For-跟随Piasy-拆轮子"><a href="#知识总结-For-跟随Piasy-拆轮子" class="headerlink" title="知识总结 - For 跟随Piasy 拆轮子"></a>知识总结 - For 跟随Piasy 拆轮子</h4><p> 最后，再回头看看 Piasy 画的流程图，将知识串起来</p>
<p> <img src="http://odzvmv4ab.bkt.clouddn.com/okhttp_full_process.png" alt="Piasy - OkHttp 整体流程图"></p>
<ul>
<li>核心方法：getResponseWithInterceptorChain - 拦截链模式（《Android 源码设计模式》 一书中有讲解），层层分明，单一责任</li>
<li>同步、异步请求差异？（异步通过提交到 ExecutorService 来实现，最终还是离不开 getResponseWithInterceptorChain 方法）</li>
<li>其中的提及到的重点拦截器：<ul>
<li>retryAndFollowUpInterceptor（负责失败重试以及重定向）</li>
<li>BridgeInterceptor（负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的相应转换为用户友好响应）</li>
<li>CacheInterceptor（负责读取缓存直接返回、更新缓存）</li>
<li>ConnectInterceptor（负责与服务器建立连接）</li>
<li>CallServerInterceptor（负责向服务器发送给请求数据、从服务器读取响应数据）</li>
</ul>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 源码分析 </tag>
            
            <tag> 拆轮子笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android WebView全面总结]]></title>
      <url>http://yoursite.com/2016/09/04/Android-WebView%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="知识点汇总："><a href="#知识点汇总：" class="headerlink" title="知识点汇总："></a>知识点汇总：</h2><ul>
<li>WebView概述</li>
<li>捕获url方式</li>
<li>js交互</li>
<li>内存泄漏</li>
<li>WebView 缓存机制<a id="more"></a>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>结合H5页面开发的App日渐多了起来，而WebView正是Html与Native的纽带，今天就借着一个新的项目需求顺便做一下WebView的知识总结，如有错漏，恳请大家指点指点。（项目需求：将适配好的网页打包成App，并能够调用系统摄像头进行二维码识别、拍照或是选择本地图片上传、获取用户位置等）</p>
<hr>
<h2 id="WebView-小科普"><a href="#WebView-小科普" class="headerlink" title="WebView 小科普"></a><strong>WebView 小科普</strong></h2><ul>
<li><p>官方文档<br><strong>Class Overview</strong><br>A View that displays web pages. This class is the basis upon which you can roll<br>your own web browser or simply display some online content within your Activity.<br>It uses the WebKit rendering engine to display web pages and includes methods<br>to navigate forward and backward through a history, zoom in and out, perform text searches and more.<br>理解：WebView是一个显示网页的一个View，基本应用于浏览器或是Activity中网页的简单显示。使用了WebKit渲染引擎实现一系列神奇的功能。</p>
<p><strong>Basic usage</strong><br>By default, a WebView provides no browser-like widgets, does not enable JavaScript and web page errors are ignored.<br>理解：默认情况，WebView并没有开启对JavaScript的支持，仅起展示作用，因此，我们需要进一步配置WebView才能满足各种各样的需求。</p>
</li>
</ul>
<h3 id="WebView基本使用"><a href="#WebView基本使用" class="headerlink" title="WebView基本使用"></a><strong>WebView基本使用</strong></h3><ul>
<li>在 AndroidManifest.xml 中添加联网权限（如果webView需要联网的话，仅加载本地html、js文件则不需要添加联网权限）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!--另外附上一些可能会用到的权限：--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!--获取网络状态权限（情景：WebView联网前，应检查当前网络状态）--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!--通过WiFi或移动基站的方式获取用户错略的经纬度信息--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!--通过GPS芯片接收卫星的定位信息权限（情景：结合HTML5使用Geolocation API获取位置时）--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!--读写存储权限（情景：拍照/选择图片，涉及图片读取、编辑、压缩等功能时）--&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>一些 WebSettings 常用配置（其实还有许多没有列出来，大家可以利用IDE，点击进入方法，查看源码继续发掘）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">WebSettings  mWebSetting = mWebView.getSettings();  <span class="comment">//获取WebSetting</span></div><div class="line">setJavaScriptEnabled(<span class="keyword">true</span>);<span class="comment">//让WebView支持JavaScript</span></div><div class="line">setDomStorageEnabled(<span class="keyword">true</span>);<span class="comment">//启用H5 DOM API （默认false）</span></div><div class="line">setDatabaseEnabled(<span class="keyword">true</span>);<span class="comment">//启用数据库api（默认false）可结合 setDatabasePath 设置路径</span></div><div class="line">setCacheMode(WebSettings.LOAD_DEFAULT)<span class="comment">//设置缓存模式</span></div><div class="line">setAppCacheEnabled(<span class="keyword">true</span>);<span class="comment">//启用应用缓存（默认false）可结合 setAppCachePath 设置缓存路径</span></div><div class="line">setAppCacheMaxSize()<span class="comment">//已过时，高版本API上，系统会自行分配</span></div><div class="line">setPluginsEnabled(<span class="keyword">true</span>);  <span class="comment">//设置插件支持</span></div><div class="line">setRenderPriority(RenderPriority.HIGH);  <span class="comment">//提高渲染的优先级</span></div><div class="line">setUseWideViewPort(<span class="keyword">true</span>);  <span class="comment">//将图片调整到适合webview的大小</span></div><div class="line">setLoadWithOverviewMode(<span class="keyword">true</span>); <span class="comment">// 缩放至屏幕的大小</span></div><div class="line">setSupportZoom(<span class="keyword">true</span>);  <span class="comment">//支持缩放，默认为true</span></div><div class="line">setBuiltInZoomControls(<span class="keyword">true</span>); <span class="comment">//设置内置的缩放控件（若SupportZoom为false，该设置项无效）</span></div><div class="line">setDisplayZoomControls(<span class="keyword">false</span>); <span class="comment">//隐藏原生的缩放控件</span></div><div class="line">setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN); <span class="comment">//支持内容重新布局</span></div><div class="line">supportMultipleWindows();  <span class="comment">//支持多窗口</span></div><div class="line">setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);  <span class="comment">//关闭webview中缓存</span></div><div class="line">setAllowFileAccess(<span class="keyword">true</span>);  <span class="comment">//设置可以访问文件</span></div><div class="line">setNeedInitialFocus(<span class="keyword">true</span>); <span class="comment">//当webview调用requestFocus时为webview设置节点</span></div><div class="line">setJavaScriptCanOpenWindowsAutomatically(<span class="keyword">true</span>); <span class="comment">//支持通过JS打开新窗口</span></div><div class="line">setLoadsImagesAutomatically(<span class="keyword">true</span>);  <span class="comment">//自动加载图片</span></div><div class="line">setDefaultTextEncodingName(<span class="string">"utf-8"</span>);<span class="comment">//设置编码格式</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实际应用中，一般配置即可满足基本需求</span></div><div class="line">mWebSettings.setSupportZoom(<span class="keyword">true</span>);</div><div class="line">mWebSettings.setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">mWebSettings.setLoadWithOverviewMode(<span class="keyword">true</span>);</div><div class="line">mWebSettings.setUseWideViewPort(<span class="keyword">true</span>);</div><div class="line">mWebSettings.setDefaultTextEncodingName(<span class="string">"utf-8"</span>);</div><div class="line">mWebSettings.setLoadsImagesAutomatically(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
<ul>
<li>加载网页、本地、assets中的html页面基本方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//网页</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_NET = <span class="string">"http://www.google.com"</span>; <span class="comment">// 记得加 "http://"</span></div><div class="line"><span class="comment">//assets 中的 html 资源</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_LOCAL =<span class="string">"file:///android_asset/xxx.html路径"</span>; </div><div class="line"><span class="comment">//SD 卡中的 html 资源</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_SD_CARD =<span class="string">"content://com.android.htmlfileprovider/mnt/sdcard/xxx.html"</span>; </div><div class="line">mWebView.loadUrl(URL_NET);</div><div class="line">mWebView.loadUrl(URL_LOCAL);</div><div class="line">mWebView.loadUrl(URL_SD_CARD);</div></pre></td></tr></table></figure>
<h3 id="WebViewClient-与-WebChromeClient"><a href="#WebViewClient-与-WebChromeClient" class="headerlink" title="WebViewClient 与 WebChromeClient"></a><strong>WebViewClient 与 WebChromeClient</strong></h3><p><a href="http://blog.csdn.net/linghu_java/article/details/6927439" target="_blank" rel="external">WebViewClient与WebChromeClient的区别</a></p>
<ul>
<li>WebViewClient 用于帮助WebView处理各种通知、请求事件</li>
</ul>
<table>
<thead>
<tr>
<th>WebViewClient 常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>shouldOverrideUrlLoading</td>
<td>加载时调用，可捕获url</td>
</tr>
<tr>
<td>onPageStart</td>
<td>开始加载时调用（可以设置加载中提示）</td>
</tr>
<tr>
<td>onPageFinish</td>
<td>加载完成时调用（无法打开也是完成的一种，在这里取消加载提示显示）</td>
</tr>
<tr>
<td>onReceiveError</td>
<td>接收到错误信息时调用（通常在该方法中处理404之类的加载错误，但这里<strong>有点坑</strong>，API23中，在低于API23的设备上运行时，该方法失效，不调用<strong>我猜原因可能是：</strong> 新版的onReceiveError不再接收网页连接的错误，而是接收WebView自身运行出现的错误，另外有onReceivedHttpError方法来接收（然而在我的测试中，该方法还是未能接收到404错误）。可暂时用API23过时的方法<em>“onReceivedError(WebView view, int errorCode, String description, String failingUrl)”</em>替代新版本中的<em>“onReceivedError(WebView view, WebResourceRequest request, WebResourceError error)”</em>；）<a href="http://stackoverflow.com/questions/32769505/webviewclient-onreceivederror-deprecated-new-version-does-not-detect-all-errors" target="_blank" rel="external">传送门：stackoverflow Q&amp;A</a></td>
</tr>
</tbody>
</table>
<ul>
<li>WebChromeClient 用于辅助 WebView处理Javascript的对话框，网站图标、Title、位置、加载进度等信息</li>
</ul>
<table>
<thead>
<tr>
<th>WebChromeClient 常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onProgressChanged</td>
<td>加载进度</td>
</tr>
<tr>
<td>onReceivedTitle、onReceivedIcon</td>
<td>获取网页标题、图标</td>
</tr>
<tr>
<td>onGeolocationPermissionsShowPrompt</td>
<td>页面发起GEO定位请求时调用</td>
</tr>
<tr>
<td>…</td>
<td>WebChromeClient源码中对各种方法都有详细解析，需要用到的时候查一下即可</td>
</tr>
</tbody>
</table>
<ul>
<li>两者用法都是简单的set方法<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mWebView.setWebViewClient(mWebViewClient);</div><div class="line">mWebView.setChromeClient(mWebChromeClient);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="WebView与Javascript交互"><a href="#WebView与Javascript交互" class="headerlink" title="WebView与Javascript交互"></a><strong>WebView与Javascript交互</strong></h3><ul>
<li>前提条件：setJavaScriptEnabled(true)</li>
<li>调用js方法<br> <code>mWebView.loadUrl(&quot;javascript: 方法名(&#39;&quot;+参数+&quot;&#39;)&quot;);</code></li>
<li>js调用android中方法<br>4.2及之前版本该方法存在漏洞：<a href="http://blog.csdn.net/leehong2005/article/details/11808557" target="_blank" rel="external">Android WebView的Js对象注入漏洞解决方案</a>、<a href="http://www.jianshu.com/p/93cea79a2443" target="_blank" rel="external">JS与WebView交互存在的一些问题</a><blockquote>
<p>引用”漏洞描述”：<br>1，WebView添加了JavaScript对象，并且当前应用具有读写SDCard的权限，也就是：android.permission.WRITE_EXTERNAL_STORAGE<br>2，JS中可以遍历window对象，找到存在“getClass”方法的对象的对象，然后再通过反射的机制，得到Runtime对象，然后调用静态方法来执行一些命令，比如访问文件的命令.<br>3，再从执行命令后返回的输入流中得到字符串，就可以得到文件名的信息了。然后想干什么就干什么，好危险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This method can be used to allow JavaScript to control the host</div><div class="line"> * application. This is a powerful feature, but also presents a security</div><div class="line"> * risk for apps targeting&#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#JELLY_BEAN&#125; </div><div class="line"> * or earlier.</div><div class="line"> * /</div><div class="line"> //理解：该方法可以让js控制app，很强势，但在API17（4.2）及之前的版本存在安全问题</div><div class="line"> addJavascriptInterface(Object object, String name);</div><div class="line"> </div><div class="line"> //使用方法</div><div class="line"> mWebView.addJavascriptInterface(MethodObject,"name");</div><div class="line"></div><div class="line"> //还需要写一个方法类</div><div class="line"> class MethodObject extends Object &#123;</div><div class="line">    //无参函数，js中通过：var str = window.name.HtmlcallJava(); 获取到</div><div class="line">    <span class="doctag">@JavascriptInterface</span></div><div class="line">    public String HtmlcallJava() &#123;</div><div class="line">        return "Html call Java";</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //有参函数，js中通过：window.jsObj.HtmlcallJava2("IT-homer blog");</div><div class="line">    <span class="doctag">@JavascriptInterface</span></div><div class="line">    public String HtmlcallJava2(final String param) &#123;</div><div class="line">        return "Html call Java : " + param;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="WebView小技巧"><a href="#WebView小技巧" class="headerlink" title="WebView小技巧"></a><strong>WebView小技巧</strong></h3><ul>
<li>捕获Url</li>
<li>重定向问题，推荐<a href="http://blog.csdn.net/t12x3456/article/details/39134961" target="_blank" rel="external">WebView加载重定向url影响goBack()解决方案</a>、<a href="http://spencer-dev.com/blog/2015/android-webview-wang-zhi-zhong-ding-xiang-ying-xiang-goback.html/" target="_blank" rel="external">重定向影响goBack()</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 捕获Url</div><div class="line"> * 多页面在同一个WebView打开</div><div class="line"> * /</div><div class="line"><span class="doctag">@Override</span></div><div class="line">public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</div><div class="line">			if(url.equal("需要捕获的url"))&#123;</div><div class="line">				// 捕获后的操作</div><div class="line">				// 前面提到的项目需求中，调用系统摄像头识别二维码、拍照、选择本地图片等功能</div><div class="line">				// 均可该方式简单实现（当然addJavascriptInterface方式也能达到相同效果）</div><div class="line">				return true;</div><div class="line">			&#125;</div><div class="line">            view.loadUrl(url);//该方法可让多页面在同一个WebView中打开（不用新建Activity或是调用浏览器）</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">//我们再回头看看该方法的官方API，会发现上面的方法多少还是有点坑（重定向问题，出现原理）     </div><div class="line">/**</div><div class="line">     * Give the host application a chance to take over the control when a new</div><div class="line">     * url is about to be loaded in the current WebView. If WebViewClient is not</div><div class="line">     * provided, by default WebView will ask Activity Manager to choose the</div><div class="line">     * proper handler for the url. If WebViewClient is provided, return true</div><div class="line">     * means the host application handles the url, while return false means the</div><div class="line">     * current WebView handles the url.</div><div class="line">     * /</div><div class="line">     </div><div class="line">     //该方法为应用提供处理新url的机会，如果WebView没有设置WebViewClient，WebView会调用系统来找到合适应用来处理该url；而如果设置了WebViewClient，该方法返回true说明该url由应用自行处理，而false则交给WebView自动处理。</div><div class="line">     </div><div class="line">     //那么，问题来了：上面方法中，我们returne的是true，而处理代码是让WebView直接loadUrl（不管什么情况都是直接loadUrl，并把该url加入历史记录），如果该url会重定向到其他url，如果调用了goBack，返回到该url，而该url又重定向到另外一个url，造成goBack失败。</div><div class="line">     </div><div class="line">     //解决方式：将处理重定向的url交给webView本身，webView能自行判断url是否为重定向url，能够确保历史记录准确性，自身跳转则需要另想办法：</div><div class="line">     //1. 与前端人员协商能够去掉重定向url？ </div><div class="line">     //2. 建立自身的历史栈，舍弃goBack()方法，移除重定向url与重定向后的url，根据需求自行进行loadUrl（需要思考一个合理的跳转逻辑）</div><div class="line">     //3. 建立自身的历史栈，与前端配合，提供js函数判断是否为重定向url，捕获url调用js函数，若为重定向url则作过滤处理，则不加入历史栈</div><div class="line">public boolean shouldOverrideUrlLoading(WebView view, String url)&#123;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 返回上一浏览页面</div><div class="line"> * /</div><div class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;       </div><div class="line">    if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123;       </div><div class="line">        mWebView.goBack();       </div><div class="line">        return true;       </div><div class="line">    &#125;       </div><div class="line">    return super.onKeyDown(keyCode, event);       </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WebClient 中 onReceivedError 的旧方法（API23 已过时）</span></div><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedError</span><span class="params">(WebView view, <span class="keyword">int</span> errorCode, String description, String failingUrl)</span> </span>&#123;</div><div class="line">      showErrorTips();<span class="comment">// 显示错误页面/提示（大家可以将 WebView 错误页面替换掉、结合 mWebView.reload 实现点击重连）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="WebView-进阶"><a href="#WebView-进阶" class="headerlink" title="WebView 进阶"></a><strong>WebView 进阶</strong></h2><h3 id="WebView-内存泄漏问题"><a href="#WebView-内存泄漏问题" class="headerlink" title="WebView 内存泄漏问题"></a><strong>WebView 内存泄漏问题</strong></h3><ul>
<li><a href="http://my.oschina.net/zhibuji/blog/100580" target="_blank" rel="external">Android WebView Memory Leak</a></li>
</ul>
<p>WebView解析网页时会申请Native堆内存用于保存页面元素，当页面较复杂时会有很大的内存占用。如果页面包含图片，内存占用会更严重。并且打开新页面时，为了能快速回退，之前页面占用的内存也不会释放。有时浏览十几个网页，都会占用几百兆的内存。这样加载网页较多时，会导致系统不堪重负，最终强制关闭应用，也就是出现应用闪退或重启。</p>
<p>由于占用的都是Native堆内存，所以实际占用的内存大小不会显示在常用的DDMS Heap工具中（这里看到的只是Java虚拟机分配的内存，一般即使Native堆内存已经占用了几百兆，这里显示的还只是几兆或十几兆）。只有使用adb shell中的一些命令比如dumpsys meminfo 包名，或者在程序中使用Debug.getNativeHeapSize()才能看到。</p>
<p>据说由于WebView的一个BUG，即使它所在的Activity(或者Service)结束也就是onDestroy()之后，或者直接调用WebView.destroy()之后，它所占用这些内存也不会被释放。</p>
<p>解决这个问题最直接的方法是：把使用了WebView的Activity(或者Service)放在单独的进程里。然后在检测到应用占用内存过大有可能被系统干掉或者它所在的Activity(或者Service)结束后，调用System.exit(0)，主动Kill掉进程。由于系统的内存分配是以进程为准的，进程关闭后，系统会自动回收所有内存。</p>
<h3 id="WebView-缓存机制"><a href="#WebView-缓存机制" class="headerlink" title="WebView 缓存机制"></a><strong>WebView 缓存机制</strong></h3><p> 推荐文章<a href="http://blog.csdn.net/t12x3456/article/details/13745553" target="_blank" rel="external">Android WebView缓存机制详解</a>、<a href="http://www.androidchina.net/3168.html" target="_blank" rel="external">深入探究webView的缓存机制</a></p>
<p>经过一番搜索得来的结果：</p>
<pre><code>1. WebView缓存分为：页面缓存和数据缓存。页面缓存指加载网页时，对页面或资源数据的缓存。一般使用RE管理器进入目录： “/data/data/(packageName)/cache/org.chromium.android_webview“可看到；
</code></pre><p>   数据缓存又分为 AppCache 与 DOM Storage 。AppCache可以有选择地缓存我们所想要缓存的东西；DOM Storage 则是HTML5的一个缓存机制，常用于存储简单的表单数据，关于DOM Storage，详情可学习参考下 <a href="http://www.ibm.com/developerworks/cn/web/1107_gaoly_html5storage/" target="_blank" rel="external">“浅谈HTML5 的DOM Storage机制”</a> 一文。</p>
<pre><code>2. webView的缓存模式：
</code></pre><p>  LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据<br>LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。<br>LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式<br>LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.<br>LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</p>
<ol>
<li>将缓存路径转移到外置sd卡<br>查看 Context 类API 发现这样一个方法，重写该方法即可（注意赋予相关权限，但Android 4.4 上权限限制，会使该方法失效）<br>另外趁机附上：<a href="http://dragon.leanote.com/post/Android%E7%9A%84%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%8C%BA%E6%9D%83%E9%99%90%EF%BC%88%E8%AF%91%EF%BC%89" target="_blank" rel="external">Android 外部存储权限分析（译）</a>、<a href="http://www.cnblogs.com/mengdd/p/3742623.html" target="_blank" rel="external">Android存储访问及目录</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns the absolute path to the application specific cache directory</div><div class="line">     * on the filesystem. These files will be ones that get deleted first when the</div><div class="line">     * device runs low on storage.</div><div class="line">     * There is no guarantee when these files will be deleted.</div><div class="line">     *</div><div class="line">     * &lt;strong&gt;Note: you should not &lt;em&gt;rely&lt;/em&gt; on the system deleting these</div><div class="line">     * files for you; you should always have a reasonable maximum, such as 1 MB,</div><div class="line">     * for the amount of space you consume with cache files, and prune those</div><div class="line">     * files when exceeding that space.&lt;/strong&gt;</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> The path of the directory holding application cache files.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #openFileOutput</div><div class="line">     * <span class="doctag">@see</span> #getFileStreamPath</div><div class="line">     * <span class="doctag">@see</span> #getDir</div><div class="line">     */</div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> File <span class="title">getCacheDir</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">File extStorageAppCachePath = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getCacheDir</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//读写权限判断</span></div><div class="line">        <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) &#123;</div><div class="line">            <span class="comment">//获取外置存储路径，生成相应缓存路径</span></div><div class="line">            File externalStorageDir = Environment.getExternalStorageDirectory();</div><div class="line">            <span class="keyword">if</span> (externalStorageDir != <span class="keyword">null</span>) &#123;</div><div class="line">                extStorageAppCachePath = <span class="keyword">new</span> File(externalStorageDir.getAbsolutePath() +</div><div class="line">                        File.separator + <span class="string">"Android"</span> + File.separator + <span class="string">"data"</span> + File.separator + getPackageName() + File.separator + <span class="string">"webViewCache"</span>);</div><div class="line">                <span class="comment">//路径不存在，创建</span></div><div class="line">                <span class="keyword">if</span> (!extStorageAppCachePath.exists()) &#123;</div><div class="line">                    <span class="keyword">if</span> (!extStorageAppCachePath.mkdirs()) &#123;</div><div class="line">                        <span class="comment">//创建路径失败</span></div><div class="line">                        extStorageAppCachePath = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.getCacheDir();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//成功创建，返回路径</span></div><div class="line">                        <span class="keyword">if</span> (extStorageAppCachePath != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="keyword">return</span> extStorageAppCachePath;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//路径已存在，直接返回</span></div><div class="line">                    <span class="keyword">if</span> (extStorageAppCachePath != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> extStorageAppCachePath;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getCacheDir();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p> 本文主要是对自己学习WebView的过程、应用WebView遇到的一些问题，结合强大的网络资源总结而来，如果错漏，恳请指教，希望能给大家提供小小的帮助，在分享技术过程中，提升、成长！（有很长一段时间没有发布过博客，<strong>贵在坚持，贵在坚持！</strong>）</p>
]]></content>
      
        
        <tags>
            
            <tag> Android widget </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
